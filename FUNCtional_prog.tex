\input{_head.tex}
%\usepackage{hyperref}
\newif\ifFULL
\FULLtrue

\begin{document}
\footskip=30pt
\date{}
\title{Функциональное программирование}
\maketitle
\pagestyle{plain}
%\fontsize{13}{14pt}\selectfont   
%\fontsize{11}{12pt}\selectfont   
\setcounter{secnumdepth}{0}  % turn off numeration of sections
\input{style_csharp.tex}

\fontsize{18pt}{18pt}\selectfont

%\setcounter{tocdepth}{4}
%\tableofcontents 


\lstset{language=C++}  % default language



\begin{minipage}{0.46\textwidth}
\begin{lstlisting}[caption="C\#"]
using System;
void 
Thread myThread = new Thread(new ThreadStart(Count));
myThread.Start(); // запускаем поток
str s = '123';
set t = {1,2,3};
\end{lstlisting}	
 
\end{minipage}
\hfill
\begin{minipage}{0.46\textwidth}

\begin{lstlisting}[caption="Python", language=Python]
int x = 0;
str s = '123';
set t = {1,2,3};
\end{lstlisting}	
 
\end{minipage}



\section{Введение}$~$

Императивный стиль --- циклы и изменяемые переменные.

Функциональный стиль --- чистые функции, неизменяемые переменные, нет циклов while, for и т.п.

\vspace{3mm}

Фунциональный подход используется при программировании на основе \emph{событий} (<<reactive>>), а также при параллельном программировании.

История.

Функциональное программирование возникло задолго до ООП.


Чистыми функциональными языками являются ML. Однако они редко используются на практике. Чаще приходится смешивать объектно-ориентированное и функциональное программирование.

Последнии версии языков C\# (с версии 3), JAVA (с версии 8) и даже C++ (С++11)  поддерживают многие элементы функционального программирования. \verb|Python| изначально проектировался с поддержкой ООП, функционального и других парадигм.


\subsubsection{Пример}$~$

Задача: Найти сумму кубов элементов заданной последовательности, т.е. $\sum\limits_{i=1}^{N} x_i^3$.

\vspace{3mm}

Императивный стиль:

\begin{minted}{python}
a = [3, -2, 1, 4, 2, 0, 3]
s = 0
for x in a:
	s += x**3 
\end{minted}



\vspace{5mm}

Функциональный стиль:

\begin{minted}{python}
m = map(lambda x: x**3, a)
s = reduce(lambda x, y: x+y, m)
\end{minted}



\section{Основы ФП. Лямбда-исчисление}$~$



\section{Средства функционального программирования на Python}
\lstset{language=Python}  % default language



\url{https://habrahabr.ru/post/257903/} - Введение в функциональное программирование на Python

\subsection{lambda-выражения}$~$

\verb|lambda arg1, arg2,..., argN : выражение|

\begin{lstlisting}[caption="lambda", language=Python]
add = lambda x, y, z: x + y + z
\end{lstlisting}


\subsection{Функция map}$~$



\section{Сравнение функционального и императивного подхода}

\subsection{Фильтрация}$~$

Пусть \verb|ls = [1, 6, 3, 2, 4, 2, 2, 4, 5, 3, 2, 7, 5, 4, 2]|

\begin{lstlisting}[caption="filter", language=Python]
>>> newls = list(filter(lambda x: x % 2 == 0, ls))
[6, 2, 4, 2, 2, 4, 2, 4, 2]
\end{lstlisting}

\begin{lstlisting}[caption="list generator", language=Python]
newls = [x for x in ls if x%2 == 0]
\end{lstlisting}

\begin{lstlisting}[caption="Си-подобный код", language=Python]
newls = []
for x in ls:
	if x%2 == 0:
		newls.append(x)
print(newls)		
\end{lstlisting}

\begin{lstlisting}[caption="Генераторные выражения", language=Python]
it = (x for x in ls if x%2 == 0)
for x in it: 
	print(x)
\end{lstlisting}
но можно и так:

\begin{lstlisting}[caption="Генераторные выражения", language=Python]
newls = list((x for x in ls if x%2 == 0))
newls = list(x for x in ls if x%2 == 0)
\end{lstlisting}


Замечание:


\section{Модуль Functools}$~$

\url{https://python-scripts.com/import-functools}




%----------

\section{Применение функционального подхода на Python и C\#}$~$

\subsection{Рекурсия. Анонимная рекурсия}$~$

Вычисление факториала

В императивном стиле (с помощью циклов, без рекурсий):

\begin{lstlisting}[caption="C\#", language=C++]
public static int fact(int n) {
	int f = 1; 
	for(int i = 1; i<=n; i++) {
		f *= i;
	}
	return f;
}
\end{lstlisting}	

Через рекурсию -- функциональный стиль:


\begin{lstlisting}[caption="Haskell"]
> let fac n = if n == 0 then 1 else n * fac (n-1)
> fac(5)
\end{lstlisting}	
        
\begin{lstlisting}[caption="Python"]
>>> fac = lambda n: n*fac(n-1) if n>0 else 1
>>> fac(5)
\end{lstlisting}	

\begin{lstlisting}[caption="C\#", language=C++]
Func<int, int> Fact = null;
Fact  = (x) => x > 1 ? x * Fact(x-1) : 1;
Console.WriteLine(Fact(5));
\end{lstlisting}



Но здесь есть проблема.
                
% http://myrefpool.blogspot.com.by/2010/06/c.html

\begin{lstlisting}[caption="C\#", language=C++]
Func<int, int> Fact = null;
Fact  = (x) => x > 1 ? x * Fact(x-1) : 1;
Func<int, int> g = Fact;
Console.WriteLine("1) Fact(5) = " + Fact(5));
Console.WriteLine("1) g(5) = " + g(5));		

Fact  = (x) => x + 1;
Console.WriteLine("2) Fact(5) = " + Fact(5));
Console.WriteLine("2) g(5) = " + g(5));	
\end{lstlisting}        
Какой будет результат?

\vspace{10mm}

Таким образ, здесь это не настоящая рекурсия. Рекурсия требует, чтобы функция вызывала саму себя. В данном случае функция \verb|g| просто вызывает \textbf{делегат}, на который ссылается локальная переменная \verb|g|. 

Решение проблемы:

\begin{lstlisting}[caption="C\#", language=C++]
(f, n) => n > 1 ? f(f,n - 1) + f(f,n - 2) : n
\end{lstlisting}     

Чтобы это реализовать и преобразовать лямбду к делегату, необходимо определить тип делегата. Начнем с типа fib, Func. Возвращаемый тип - int, принимаемым вторым аргументов типом также должен быть int. Что касается первого аргумента, им должен быть делегат, который должен вызываться с теми же аргументами, которые мы определяем в данном случае, что и есть рекурсия:
\begin{lstlisting}[caption="C\#", language=C++]
delegate int Recursive(Recursive r, int n);
\end{lstlisting}         

Теперь можно использовать лямбду, определенную выше:
\begin{lstlisting}[caption="C\#", language=C++]
delegate int Recursive(Recursive r, int n);
...
Recursive fn = (f, n) => n > 1 ? f(f, n-1) : 1;
Console.WriteLine("out: " + fn(fn, 5));
\end{lstlisting}   


На python:

\begin{lstlisting}[caption="Python", language=Python]
>>> fx = lambda f,x : x*f(f,x-1) if x>0 else 1
>>> fx(fx,5)
120
\end{lstlisting} 

Такой прием называется <<анонимной рекурсией>>.






\end{document} 


%Lit:

% https://habrahabr.ru/post/132554/ - Как работает yield

% https://www.ibm.com/developerworks/ru/library/l-prog/ - Функциональное программирование на языке Python, Часть 1

% https://www.ibm.com/developerworks/ru/library/l-python_details_03/
% Тонкости использования языка Python: Часть 3. Функциональное программирование

% https://hackernoon.com/is-c-7-starting-to-look-like-a-functional-language-d4326b427aaa - Is C#7 starting to look like a functional language?

% https://www.manning.com/books/functional-programming-in-c-sharp -- Functional Programming in C#

% https://medium.com/@naveenrtr/introduction-to-functional-programming-with-c-b167f15221e1 -- Introduction to functional programming with C#
% https://livebook.manning.com/#!/book/functional-programming-in-c-sharp/chapter-4/1

% http://cpp-reference.ru/patterns/structural-patterns/decorator/ - декораторы

% Понимаем декораторы в Python'e, шаг за шагом. Шаг 2 - https://habrahabr.ru/post/141501/