\input{_head.tex}
\newif\ifFULL
\FULLtrue

\begin{document}
\footskip=30pt
\date{}
\title{Phyton и теория графов}
\maketitle
\pagestyle{plain}
%\fontsize{13}{14pt}\selectfont   
%\fontsize{11}{12pt}\selectfont   
\setcounter{secnumdepth}{3}  % turn off numeration of sections
\input{styles/style_python.tex}

\setcounter{tocdepth}{4}
\tableofcontents 



\section{Краткая справка по языку Python}



\subsection{Полезные функции}$~$

\verb|exec(obj[, globals[, locals]])| --- динамически исполняет указанный код. Здесь obj --- cтрока кода, либо объект кода.


\verb|eval(expression, globals=None, locals=None)| --- разбирает и исполняет указанное выражение. Возвращает какой-то результат.

Например, \verb|x = 1; eval('x+1')|.

Функциям eval() и exec() можно передавать результаты функций globals() и locals().



\section{Лабораторные работы}

\begin{enumerate}
 \item 1) Типы данных, строки и базовые инструкции (циклы). 2) Ввод-вывод в файл, из файла.
 \item Пакет Numpy (работа с массивами)
 \item Итераторы и генераторы. 
 \item ООП. Классы и перегрузка операций
 \item Наследование
 \item GUI: tkinter
 \item Элементы функционального программирования. Функции-генераторы. Декораторы.
 \item Потоки
 \item NLTK и обработка текста. 
 \item Pandas - анализ данных
 \item web: Flask, Django 
\end{enumerate}


\section{Содержание лекций}


\begin{enumerate}
 \item Типы данных. Базовые инструкции (циклы). Ввод-вывод (файлы).
 \item Пакет Numpy (работа с массивами)
 \item Итераторы и генераторы. 
 \item ООП. Классы и перегрузка операций. Наследование
 \item Элементы функционального программирования. Функции-генераторы. Декораторы.
 \item Высокопроизводительные коллекции (модуль collections). Weekref. Deepcopy.
 \item GUI: tkinter
 \item Потоки (GIL)
 \item NLTK и обработка текста. 
 \item Pandas - анализ данных
 \item web: Flask, Django
 \item GIT 
\end{enumerate}

\vspace{5mm}
\newpage

\section{Обзор языка Python}$~$

\textbf{Python} --- мультипарадигмальный интерпретируемый язык программирования общего назначения.

\vspace{4mm}

Основные сферы применения Python:
\begin{itemize}
 \item Веб-разработка: синхоронные фреймоврки Django, Flask и асинхронные Tornado, Twisted, Aiohttp.
 \item Машинное обучение и Data science (аналитика) --- библиотеки Pandas, NumPy, SciPy, Scikit-Learn, Theano, Tensorflow и др.
 \item Научные расчеты (как альтернатива Matlab): пакеты SciPy, Nmag.
 \item Тестирование ПО.
\end{itemize}

\vspace{4mm}

Основные реализации (интерпретаторы) Python: 
\begin{itemize}
 \item \textbf{CPython} --- наиболее распространенная, эталонная реализация языка Python. CPython является интерпретатором байт-кода, написан на C. Как следствие, хорошо интегрируется с кодом, написанными на C.
 \item \textbf{Jython} = JAVA + Python. Позволяет запускать код Python на виртуальной машине JVM.
 \item \textbf{IronPython} --- интерпретаор Python, написанный на C\#.  Для платформы Microsoft .NET или Mono. 
 \item \textbf{PyPy} --- изначально был интерпретатором Python, написанным на Python. В текущих версиях используется JIT-компилятор, который превращает Python-код в машинный код во время выполнения программы. Производительность выше, чем у CPython. Имя пакета \verb|pypy|.
\end{itemize}


\vspace{4mm}

\textbf{Cython} --- отдельный язык программирования с Python-подобным синтаксисом, который транслируется в код C/C++ и компилируется.


\subsection{Пример программы на Python}$~$

\begin{lstlisting}[caption=Пример программы]
import sys
from math import sin, cos, sqrt
from numpy import *
write(sys.stdout, sqrt(3))
\end{lstlisting}

Все данные в Python являются \textbf{объектами}, в том числе встроенные типы, функции, экземпляры классов и сами классы, модули и файлы, и т.д.

\verb|help()| --- справка;

\verb|dir()| --- возвращает список атрибутов и методов произвольного объекта;

\verb|type()| --- возвращает тип объекта;


\vspace{5mm}

\textbf{Часть 1. Синтаксические конструкции языка Python}

\section{Типы данных в Python}$~$

\url{https://habrahabr.ru/post/319164/} --- Python: коллекции, часть 1/4: классификация, общие подходы и методы, конвертация

В Python используется {\bf динамическая типизация}, т.е. тип данных определяется автоматически при присвоении значения переменной.

Присвоение значения осуществляется с помощью знака равенства (\verb|=|).

\begin{lstlisting}[caption=Присвоить значение переменной]
age = 23 # Присвоение значения 23 переменной age 
print(age)
country = "Swiss" 
print(country)
\end{lstlisting}


Базовые (встроенные) типы данных в Python: 
\begin{itemize}
\item Числовые типы:~~~~ \verb|int, float, complex| % long в Python2
\item Строки (\verb|str|):~~~~~~ \verb|"Hello"| ~~либо~~ \verb|'Hello'|
\item Множества (\verb|set|):~~~ \verb|{1,2,3}|
\item Списки (\verb|list|):~~~~~~~ \verb|[True, 786, 3.14, 'text', 70.2]|
\item Кортежи (\verb|tuple|):~~~~ \verb|(True, 786, 3.14, 'text', 70.2);|
\item Словари (\verb|dict|): ~~~~~ \verb|{1 : 'One', 2 : 'Two'}|
\item Файлы: ~~~~~~~~~~~~~~~~~~ \verb|f = open(filename)|
\item Булевский тип (\verb|bool|): ~~ \verb|True, False|
\item Прочие типы: ~~~~None (класс NoneType), сами типы (класс type).
\end{itemize}

\vspace{3mm}

Преобразование типов данных: 
\begin{verbatim}
int(x [,base]), float(x), complex(real [,imag]), 
str(x), tuple(s), list(s), dict(d);
\end{verbatim}

% Как определить размер объекта в Python?
% sys.getsizeof(x) или метод объекта __sizeof__()

Документация: \url{https://docs.python.org/3/library/stdtypes.html}

\subsection{Булевский тип (bool)}$~$

Значения: \verb|True, False|.

Операции над типом bool: \verb| or, and, not|.

В False преобразуются следующие объекты: None, False, 0, 0.0, 0j, Decimal(0), Fraction(0, 1); \verb|'', (), [], {}|, set(), range(0).

Операции сравнения: \verb|<, <=, >, >=, ==, !=, is, is not|.



\subsection{Числовые типы}$~$

Встроенные числые типы в Python3 --- \verb|int, float, complex|. \\
(в python2 есть также long)

Целый тип \verb|int| имеет произвольный диапазон значений.

\vspace{3mm}

Основные операции над числами: \verb|+ - * / **|.

Целая часть и остаток: \verb|// %|.


\vspace{3mm}

Преобразование к другим система счисления: \verb|int, bin, hex, oct; int(str,base)|.

Есть также \verb|format()| (и \verb|f'| в python-3.6):
\begin{lstlisting}
>>> bin(14)
'0b1110'
>>> format(14, 'b')
'1110'
>>> f'{14:b}'  # python >=3.6
'1110'
\end{lstlisting}

\vspace{3mm}

Модули \verb|numbers, fractions| --- расширенные возможности для работы с числами.

Встроенные математические функции: \verb|sqrt, abs, pow|. Больше в модуле \verb|math|.


\subsection{Списки (класс list)}$~$

\begin{lstlisting}[caption=Списки]
A = [1, 3, 3, 2]
print(A[0]) # обращение по индексу
B = [a*a for a in A]   # генератор списков
print(A)   # [1, 3, 3, 2]
print(B)   # [1, 9, 9, 4]
\end{lstlisting}

\verb|len()| --- встроенная функция, возвращает количество элементов в последовательности (в списке и т.п.).

\verb|in| --- проверят, содержит ли последовательность данное значение (\verb|x in ls|).

Некоторые методы класса list:
\begin{itemize}
 \item Вставка и удаление элементов: \verb|append(), insert(), remove(), pop()|.
 \item Сортировка элементов списка: \verb|sort()| и \verb|reverse()|.
 \end{itemize}
(Например, \verb|insert(index, object)s| --- для вставки нового элемента в середину или начало).


Копирование списков.

\begin{lstlisting}
>>> L = [1, 2, 3]
>>> S = L
>>> L[0] = 9   # изменим первый элемент списка L
>>> L
[9, 2, 3]
>>> S				# в списке S первый элемент тоже изменился
[9, 2, 3]		# так как это один и тот же список на самом деле
\end{lstlisting}

Если же нам нужно сделать реальную копию списка, то для этих целей существует метод \verb|copy()|.

\begin{lstlisting}
>>> L = [1, 2, 3]
>>> S = L.copy()
>>> L[0] = 9
>>> L
[9, 2, 3]
>>> S       # теперь все в порядка
[1, 2, 3]   # список S не затронут
\end{lstlisting}

Почему так?

--- Инструкция присваивания (\verb|=|) всегда создает ссылку на объект (но не создает копии объектов).

--- Переменные создаются при первом присваивании.

--- Перед использованием переменной ей должно быть присвоено значение.




\vspace{3mm}
{\bf Внутренняя реализация списков в CPython}

Питоновкий \verb|list| --- аналог \verb|vector| в STL, и реализован как одномерный массив указателей, а именно в виде структуры

\begin{lstlisting}
typedef struct {
    PyObject_VAR_HEAD
    PyObject **ob_item; // массив указат. на элементы списка
    Py_ssize_t allocated; // количество выделенной памяти.
} PyListObject;
\end{lstlisting}


Сложность операций:
\begin{itemize}
 \item добавление (append) элемента в конец списка --- $O(1)$;
 \item выталкивание (pop) --- $O(1)$;
 \item вставка (insert) --- $O(n)$;
 \item удаление (remove) --- $O(n)$;
\end{itemize}
\url{https://habrahabr.ru/post/273045/}



\vspace{2mm}

{\bf Сортировка} списков в Python осуществляется алгоритмом Timsort, который имеет следующую сложность: \\
Time: best --- $O(n)$, average --- $O(n \log n)$, worst --- $O(n \log n)$; \\
Memory: $O(n)$. \\
(т.е. хороший по скорости, плохой по памяти; сравнение алгоритмов --- \url{https://habrahabr.ru/company/infopulse/blog/133303/})

\vspace{3mm}

Параметры функции сортировки:

\verb'list.sort(key=func, reverse=True|False)'

Примеры:
\begin{lstlisting}
lst.sort(key=lambda obj: obj.value)
\end{lstlisting}

\vspace{3mm}





\subsection{Кортежи (Класс tuple)}$~$

\emph{Кортеж} --- это неизменяемая последовательность элементов.

\begin{lstlisting}[caption=Кортежи]
A = (1, 3, 3, 2)
A = 1, 3, 3, 2
B = 1,         # то же самое, что и (1,) или tuple([1])
\end{lstlisting}

Применение:
\begin{lstlisting}
a, b = b, a
\end{lstlisting}


\subsection{Множества}$~$

\begin{lstlisting}[caption=Множества]
A = {1, 3, 3, 2}
B = [a*a for a in A]
print(A)   # {1, 2, 3}
print(B)   # [1, 4, 9]
\end{lstlisting}




\subsection{Словари}$~$

Словарь (\verb|dict|) ---  неотсортированная колекция элементов, доступ к которым осуществляется по ключу.



\subsection{Строки}$~$

Строки в python --- последовательности unicode-символов.

Можно использовать апострофов либо кавычки. Оба варианта эквивалентны:

\begin{lstlisting}[caption=Строки]
s = 'python'
s = "python"
\end{lstlisting}

Чаще используется апостроф \verb|'|.

Тройные кавычки используются для записи многострочных блоков текста:
\begin{lstlisting}
text = '''многострочный
	блок текста'''
\end{lstlisting}


\subsubsection{Форматирование строк в стиле printf}$~$
\begin{lstlisting}
format % values
\end{lstlisting}

Например,

\begin{lstlisting}
x = 7
str = 'x=%d' % x            # out: x=7
str = '%d+%d' % (x+1, x+2)  # out: 8+9
str = '%(a)d %(b)d %(a)d' % {'a':x, 'b':x+1}  # out: 7 8 7
\end{lstlisting}


\subsubsection{Форматирование с помощью метода format}$~$


\subsubsection{Операции над отдельными символами}$~$

\verb|ord| --- 

\vspace{3mm}
Remark: Больше структур данных в модуле \verb|collections|.


\subsection{Замечание по поводу is}$~$

\textbf{is} is used in Python for testing object identity. While the \verb|==| operator is used to test if two variables are equal or not, \textbf{is} is used to test if the two variables refer to the same object.

\verb|is| сравнивает идентификаторы --- является ли это один и тот же объект (аналогично \verb|==| в Java???).
\verb|==| сравнивает, являются ли два объекта равными


\begin{lstlisting}
>>> a = 123456
>>> b = 123456
>>> a == b
True
>>> a is b
False
\end{lstlisting}

\begin{lstlisting}
>>> [1, 2] == [1, 2]
True
>>> [1, 2] is [1, 2]
False
\end{lstlisting}


\verb|id| --- идентификатор объекта:
\begin{lstlisting}
>>> id(11)
139113728
>>> id(11)
139113728
>>> id(11111111111)
3072215544
>>> id(11111111111)
3072216264
\end{lstlisting}

Некоторые часто используемые объекты (например, True и False, все односимвольные строки и короткие числа) выделяются один раз интерпретатором, и каждая переменная, содержащая этот объект, ссылается на нее. Другие номера и более крупные строки выделяются по требованию.

\verb|is| обычно используется для сравнения с \verb|None|.

\vspace{3mm}

\verb|type| --- определяет тип объекта:

\begin{lstlisting}
>>> type(55)
<class 'int'>
>>> type(55) == int
True
>>> type(55) is int
True
>>> print(int)
<class 'int'>
\end{lstlisting}

\vspace{3mm}

\verb|isinstance(x, A)| --- определяет принадлежит ли объект \verb|x| данному классу \verb|A| либо производному от него.









%------------------------------------------
\newpage

\section{Управляющие операторы (циклы и ветвления)}



Оператор ветвления представлен единственной условной инструкцией \verb|if|. 

\begin{lstlisting}
if <условие1>:
	<блок1>
elif <условие2>:
	<блок2>	
else:
	<блок3>	
\end{lstlisting}

Например,

\begin{lstlisting}
if 1 > 2:
	print('условие выполнено')
\end{lstlisting}


В Python нет оператора множественного выбора (switch -- case) как в C++. Вместо этого используется \verb|if|/\verb|elif|/.../\verb|elif|/\verb|else|.


\vspace{3mm}

Операторы циклов:
\begin{itemize}
 \item \verb|for .. in ..| --- обход всех элементов коллекции;
 \item \verb|while| --- цикл с предусловием\footnote{В Python нет цикла с постусловием do...while}.
\end{itemize}

Например,

\begin{lstlisting}
for x in {3, 2, 1}:
	print(x)
\end{lstlisting}

Стандартная форма цикла \verb|while| следующая:

\begin{lstlisting}
while <условие>:
	<блок>
\end{lstlisting}

Совместно с инструкциями циклов могут использоваться стандартные инструкции \verb|break| и \verb|continue|, а также менее стандартные инструкции --- \verb|pass| и \verb|else|. Инструкция \verb|pass| --- это пустая инструкция, которая ничего не делает. Инструкция \verb|else| располагается после цикла и всегда выполняется в том случае, если цикл завершается обычном способом (без прерывния с помощью \verb|break|).

Сделаем сразу замечание относительно выделения блоков кода. В отличие от многих других языков программирования, в  Python отсутствуют какие-либо ключевые слова или конструкции для выделения блока (как, например, begin...end в языке Паскале или фигурные скобки в C++). Вместо этого используются горизонтальные отступы для того, чтобы дать понять интерпретатору, где заканчивается данный блок. Например,

\begin{lstlisting}
for x in [1, 2]:
	print(x)
	print(x^2)
print(x^3)
\end{lstlisting}

В этом примере 2-ая и 3-я строки кода включены в тело цикла for и поэтому будут выполнены дважды (для x=1 и x=2), а инструкция 4-ой строки расположена после окончания цикла, и значит выполнится только один раз (для x=2).

Для формирования последовательностей чисел с заданным шагом существует функция \\
\verb|range(start, stop, step)|. Если \verb|step>0|, то она возвращает возврастающую последовательность чисел с условием 

\verb|start <= start + i * step < stop|, 

где i --- целое неотрицательное число. Например, 

\begin{lstlisting}
>>> list(range(0, 10, 2))
[0, 2, 4, 6, 8]
\end{lstlisting}


Функция range часто используется в циклах. Например, следующий код напечатает в консоль последовательность чисел 0, 2, 4, 6, 8.

\begin{lstlisting}
for x in range(0, 10, 2):
	print(x)
\end{lstlisting}

Кроме того, \verb|range| вместе с \verb|for| часто используются для генерации списков (или других последовательностей), что демонстрирует следующий пример:

\begin{lstlisting}
>>> [x**2 for x in range(0, 10, 2)]
[0, 4, 16, 36, 64]
\end{lstlisting}



%------------------------------------------

\section{Функции}

Объявление функции

\begin{lstlisting}[caption=Пример функции]
def func(x):
	return x*x
y = func(9)
print(y)
\end{lstlisting}

По умолчанию переменные локальные, т.е. находится в локальной области видимости этой функции.

Однако можно обратиться и изменять глобальные переменные, т.е. переменные, объявленные на верхнем уровне модуля.

\begin{lstlisting}[caption=Использование global]
y = 1;
def func():
	global y
	y = 2
func()
print('y =',y) # Result: y = 2
\end{lstlisting}


\subsection{Параметры по умолчанию}$~$


\begin{lstlisting}
def f(x, y = 3):
   return x+y
>>> f(5,6)
11
>>> f(5)
8
\end{lstlisting}

\begin{lstlisting}[caption=Что буде выведено?]
def foo(a=[]):
    a.append(1)
    print(a)
foo()
foo()
foo()
\end{lstlisting}

Значения по-умолчанию вычисляются один раз в момент объявления функции и ссылка на него сохраняется в атрибуте \verb|__defaults__| (для Python3).2

\begin{lstlisting}
def foo(a=[]):
	a.append(1)
	print(id(a))
foo()
foo()
foo()
\end{lstlisting}




\subsection{$\lambda$-функции}$~$

Лямбда-функция (или анонимная функция) --- это функция, при определении которой не нужно указывать ее имя. 

\begin{lstlisting}[caption=Пример $\lambda$-функции]
func = lambda x, y: x**2 + y**2
func(2, 3)
\end{lstlisting}

\begin{lstlisting}[caption=Непосредственное использование]
(lambda x: x+2)(5)
\end{lstlisting}


\begin{lstlisting}[caption=Замыкания]
multiplier = lambda n: lambda k: n*k
mul2 = multiplier(2) # mul2 - функция, умножающая на 2
\end{lstlisting}


\section{Шаблоны проектирования}$~$
\subsection{Декораторы}$~$

\emph{Декоратор} (decorator) --- структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту (например, классу или функции). 
% В JAVA аннотация \verb|@Override| просто указывает компилятору, что метод будет переопределяться (чтобы выводить предупреждение, если в базовом классе такого метода нет)

Декораторы функций --- это <<об\"ертки>> функций, которые дают нам возможность изменить поведение функции, не изменяя ее код.

Декораторы функций обеспечивают способ определния специальных режимов работы функций, обертывая их дополнительным слоем логики, реализованной в виде других функций.

\begin{lstlisting}
def bold(fn):
	def wrapped():
		return "<b>" + fn() + "</b>"
	return wrapped
 
def italic(fn):
	def wrapped():
		return "<i>" + fn() + "</i>"
	return wrapped
 
@bold
@italic
def hello():
	return "hello habr"

print('start')
print(hello())

#@italic
#@bold
#@bold
def func():
	return "func()"
func = italic(bold(bold(func)))

print(func())
\end{lstlisting}













\begin{thebibliography}{10}

\bibitem{Lutc} Лутц, М. Изучаем Python / М. Лутц. --- 4-ое изд. --- Пер. с англ. --- СПб.: Символ-Плюс, 2011. --- 1280 с.

\bibitem{Suzi} Сузи Р. А. Python : [полное руководство]. --- Санкт-Петербург [и др.] : БХВ-Петербург, 2002. --- 748 с. [чз]

\bibitem{Silen} Силен Д. Основы Data Science и Big Data. Python и наука о данных / [пер. с англ. Е. Матвеева]. --- Санкт-Петербург [и др.] : Питер, 2017. --- 336 с. 


\end{thebibliography}

\end{document} 

