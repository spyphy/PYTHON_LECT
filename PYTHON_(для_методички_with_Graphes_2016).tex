\input{_head.tex}
\newif\ifFULL
\FULLtrue

\begin{document}
\footskip=30pt
\date{}
\title{Phyton и теория графов}
\maketitle
\pagestyle{plain}
%\fontsize{13}{14pt}\selectfont   
%\fontsize{11}{12pt}\selectfont   
\setcounter{secnumdepth}{3}  % turn off numeration of sections
\input{styles/style_python.tex}

\setcounter{tocdepth}{4}
\tableofcontents 





\section{Описание языка Python}

Python ---  кросплатформенный интерпретируемый высокоуровневый язык прикладного программирования. Язык Python имеет интуитивно понятный синтаксис, что делает его достаточно простым в изучении. В тоже время это достаточно мощный язык программирования благодаря наличию огромного количества библиотек и расширений под него.  

Синтаксис языка минималистичен. Например, в нет отдельных ключевых слов для конструкции множественного выбора (как switch в C++) и циклов вида do...while (или repeat...until).

Python --- сравнительно молодой и активно развивающийся язык. Первая его версия вышла в свет в 1991 г. В настоящее время параллельно используются две версии языка Python: вторая и третья. В этом пособии примеры даны для третьей версии Python.

Python --- полностью бесплатный продукт с открытыми исходнымы кодами. Распространяется под собственной лицензией PSFL, подобной лицензии BSD.

На данный момент основными сферами применения языка Python является веб-разработка и научные вычисления. Здесь Python может конкуровать с коммерческим продуктом Matlab благодаря наличию в Python модулей расширения NumPy, SciPy, MatPlotLib и многих других. В рамках настоящего предмета нас будут интересовать возможности Python для работы графами. 


Python полностью поддерживает объектно-ориентированную парадигму, а также частично поддерживает функциональное программирование.  %Однако здесь мы не будем касаться вопросов разработки собственных классов, а также вопросов обработки исключений. Для наших целей вполне достаточно тех классов, которые уже реализованы в Python.

Некоторые понятия будут даваться в сравнении с другими высокоуровневыми языками программирования, такими как C++, C\#, JAVA, Delphi.


\subsection{Начало работы c Python}

Начинать изучение языка Python проще с примеров. Так, самая простая программа, выводящая на консоль фразу ``Hello World!'', на языке Python состоит всего из одной строки:

\begin{lstlisting}[caption=Первая программа на языке Python]
print('Hello World!')
\end{lstlisting}

В терминологии интерпретируемых языков такая программа называется сценарием. Достаточно сохранить этот сценарий в файл под именем, скажем, prog.py, а затем запустить с помощью интерпретатора языка Python. Будет получен следующим результат:

\begin{lstlisting}
$ python3 prog.py 
Hello World!
\end{lstlisting}

Если в консоли набрать \verb|python3| без параметров, то попадем в так называемый <<интерактивный режим>>. Этот режим удобен на начальной стадии изучения языка, поскольку позволят пошагово выполнять инструкции и тут же наблюдать за результатом:

\begin{lstlisting}
$ python3
Python 3.4.2 (default, Oct  8 2014, 13:14:40) 
[GCC 4.9.1] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> print("Hello World!")
Hello World!
>>> 
\end{lstlisting}

%Интерактивный режим удобен при изучении языка и проверки его основных возможностей. Поэтому этим режимом мы будем часто пользоваться.

%Замечание: Команда \verb|python| по умолчанию запускает интерпретатор языка Python версии 2. Для запуска 3-ей версии нужно указывать это явно --- \verb|python3|.  Впрочем это может зависеть от настроек ОС.

Комментарии могут быть добавлены в текст программы после символа \#:

\begin{lstlisting}
print('Hello World!') # это комментарий
\end{lstlisting}

Инструкции в Python заканчиваются переводом строки. При этом нет необходимости ставить точку с запятой (как, например, в C++), хотя ее постановка не будет ошибкой. Точка с запятой используется, если возникает необходимость разместить несколько инструкций в одной строке, например
\begin{lstlisting}
>>> x = 2; y = 3; print(x+y)
5
\end{lstlisting}



\subsection{Типы данных}

Python --- язык со строгой динамической типизацией. Строгая типизация означает, что переменная в любой момент времени имеет точно определенный тип. В языке Python тип переменной легко определить с помощью функции \verb|type|:

\begin{lstlisting}[caption=Строгая динамическая типизация]
>>> X = 10
>>> type(X)
<class 'int'>
>>> X = 'Hello'
>>> type(X)
<class 'str'>
\end{lstlisting}

Здесь знак <<равно>> (\verb|=|) --- оператор присваивания. Это аналогично синтаксису языков C/C++/JAVA. Однако в отличие от них, в Python нет необходимости объявлять тип переменной. Он определяется автоматически в ходе выполнения программы (динамическая типизация. Более того, переменная может изменить свой тип в ходе выполненения программы, если ей будет присвоено новое значение другого типа. Как говорят, в языке Python <<важнее значение, а не имя переменной>>. Удобство такого подхода проявится, например, при написании функции. Таким образом, имена переменных в Python --- это только ссылки на объекты. Они не хранят информацию о типе объекта.

К основным встроенныем типам данных языка Python относятся числа, строки, множества, списки, кортежи и словари. Рассмотрим их подробнее (в скобках будет указан тип данных, возвращаемый функцией \verb|type|). 

\begin{itemize}
\item Числовые типы, которые включают целые (\verb|int| и \verb|long|), вещественные (\verb|float|) и комплексные (\verb|complex|) числа.

\item Строка (\verb|str|) --- последовательность символов Юникода. Строки заключаются в кавчики либо в апострафы (оба варианта равноценны). Например, \verb|"Python"| или \verb|'Python'|.

\item Множество (\verb|set|). Пример множества: \verb|{1,2,3}|.

\item Список (\verb|list|) --- упорядоченная последовательность значений произвольных типов. Пример списка: \verb|[1,2,3]|.

\item Кортежь (\verb|tuple|) --- тоже список, только неизменяемый. Пример кортежа: \verb|(1,2,3)|.

\item Словарь (\verb|dict|) ---  неотсортированная колекция элементов, доступ к которым осуществляется по ключу. Пример словаря: \verb|{1:'a', 2:'b'}|. По большому счету словарь в Python --- это список кортежей.

\item Логический тип (\verb|bool|), переменные которого могут принимать только два значения: \verb|True| и \verb|False|.
\end{itemize}

В Python все типы данных реализованы в виде объектов, причем для них наиболее важные операторы уже перегружены. Поэтому работат с базовыми типами можно двумя способами: либо посредством вызова методов объектов, либо использовать перегруженные операторы. 

Продемонстрируем сказанное на примере класса \verb|int|, реализующего целые числа. Для этого класса перегружены базовые операторы \verb|+|,\verb|-|,\verb|*|, \verb|/| и \verb|**| (возвещение в степень), соответствующие основные арифметическим операция. Например, код

\begin{lstlisting}
>>> 2+3
5
\end{lstlisting}

может быть записан в эквивалентном виде с использованием метода \verb|__add__()| класса \verb|int|:

\begin{lstlisting}
>>> (2).__add__(3)
5
\end{lstlisting}

Но, конечно, так никто не пишет.

Узнать полный список методов любого класса можно посредством функции \verb|dir|, указав нужный класс в качестве аргумента этой функции. Например,

\begin{lstlisting}
>>> dir(int)
\end{lstlisting}

Для получения более детальной справки о классе и его методах используйте функцию \verb|help|:

\begin{lstlisting}
>>> help(int)
>>> help(int.__add__)
\end{lstlisting}


Среди полезных возможностей Python следует отметим возможность работы с комплексными числами. Мнимая единица задается как \verb|1j| либо \verb|1J|. Например, 

\begin{lstlisting}
>>> 1j*1j
(-1+0j)
\end{lstlisting}

Кроме того, существует модуль \verb|fractions|, который поддерживает работу с рациональными дробями, однако мы не будем его здесь рассматривать.
%Однако его здесь рассматривать не будем. Вместо этого перейдем к обзору более сложных типов данных и операций над ними.

\subsection{Списки}

Списки в Python --- это аналог массивов из других языков программирования. Поэтому они используются довольно часто. Списки в Python задаются в виде последовательности элементов, перечисленных через запятую и заключенных в квадратные скобки с обоих сторон. При этом элементы списка могут иметь любой тип (не обязательно одинаковый), в частности, они могут быть тоже списками. Рассмотрим некоторые часто используемые операции над списками.

Получить элемент списка можно, указав его номер в квадратных скобках после имени списка: 

\begin{lstlisting}
L = [1, 2, 'A', True, [3, 4]]
>>> L[0]     # первый элемента списка
1
>>> L[4][0]  # извлекаем элемент вложенного списка
3
\end{lstlisting}

Заметим, что нумерация элементов списка в Python начинается с нуля. 

Выполнить конкатенацию (объединение) двух списков можно с помощью перегруженного оператора \verb|+| (<<плюс>>):

\begin{lstlisting}
>>> [1, 2] + [5, 6]
[1, 2, 5, 6]
\end{lstlisting}

Кроме того, класс \verb|list| имеет набор различных методов для вставки и удаления элементов из списка: append(), insert(), remove(), pop(). А также методы для сортировки элементов списка: sort() и reverse().

Например, метод \verb|insert()| используется для вставки нового элемента в середину (или начало) списка. Первый аргумент этого метода указывает позицию, куда нужно вставить элемент, а через второй аргумент передается сам элемент:

\begin{lstlisting}
>>> L = [1, 2]
>>> L.insert(1, 3)
>>> L
[1, 3, 2]
\end{lstlisting}

Узнать длину списка можно с помощью функции \verb|len()|.

\begin{lstlisting}
>>> len([1,2,3])
3
\end{lstlisting}


Сделаем важное замечание относительно операция присваивания \verb|=|. Эта операция не производит копирование списка, а только создает еще одну ссылку на тот же список (т.е. хранящийся в той же области памяти). Это сделана для экономии ресурсов, однако может привести к неожиданным результатам при неправильном использовании. Рассмотрим пример.

\begin{lstlisting}
>>> L = [1, 2, 3]
>>> S = L
>>> L[0] = 9   # изменим первый элемент списка L
>>> L
[9, 2, 3]
>>> S				# в списке S первый элемент тоже изменился
[9, 2, 3]		# так как это один и тот же список на самом деле
\end{lstlisting}

Если же нам нужно сделать реальную копию списка, то для этих целей существует метод \verb|copy()|.

\begin{lstlisting}
>>> L = [1, 2, 3]
>>> S = L.copy()
>>> L[0] = 9
>>> L
[9, 2, 3]
>>> S       # теперь все в порядка
[1, 2, 3]   # список S не затронут
\end{lstlisting}

Это замечание справедливо и для всех остальных встроенных типов данных языка Python. В общем случае для операции присваивания действуют следующие правила:

--- Инструкция присваивания всегда создает ссылку на объект (но не создает копии объектов).

--- Переменные создаются при первом присваивании.

--- Перед использованием переменной ей должно быть присвоено значение.


\subsection{Множества}

В отличие от списков, множества не могут содержать повторяющихся элементов.

Для работы с множествами предусмотрены методы union(), intersection(), difference(), issubset(), смысл которых ясен из их названия. Посмотрим, как это выглядит на практике.

\begin{lstlisting}
>>> A = {1, 2}
>>> B = {2, 3}
>>> A.union(B)
{1, 2, 3}
>>> A.intersection(B)
{2}
\end{lstlisting}

Эти же операции можно записать в более компактной форме, используя перегруженные операторы:

\begin{lstlisting}
>>> A | B    # объединение множеств
{1, 2, 3}
>>> A & B    # пересечение множеств
{2}
\end{lstlisting}

%Заметим, что этот способ компактнее и нагляднее. Обозначения этих теоретико-множественных операций совпадают с соответствующими операциями над булевыми типами (что не должно удивлять). 

Также имеются операции нахождения разности множеств (\verb|A - B|) и симметрической разности (\verb|A ^ B|).

Кроме того, существуют операции над множествами, которые возвращают логическое значение истина или ложь. К ним относится операция сравнения двух множеств (\verb|A == B|), проверка вложенности одного множества в другое (\verb|A <= B|), принадлежность элемента множеству (\verb|x in A|) и другие.

Мощность множества \verb|A| (т.е. количество элементов в нем) можно получить с помощью функции \verb|len(A)|.


\subsection{Cтроки}

Строки в Python --- это не просто массив символов. В Python строки реализованы в виде отдельного класса. Однако операции над строками очень похожи на операции над списками. Например, конкатенация строк (оператор \verb|+|), получение символа по индексу (оператор \verb|[]|), получение длины строки (функция \verb|len()|), повторение строки (с помощью опертора \verb|*|) и другие. Следующий пример демонстрирует работу со строками.

\begin{lstlisting}[caption=Работа с строками]
>>> s = 'str'+'ing' # конкатенация
>>> s
'string'
>>> s[2]
'r'
>>> t = s*2  # удвоение строки
>>> t
'stringstring'
>>> len(t)
12
\end{lstlisting}

Получение подстроки.  Оператор извлечения среза из строки выглядит так: [X:Y]. X --- это индекс начала среза, а Y  --- его окончания; причем символ с номером Y в срез уже не входит. Если отсутствует первый индекс, то срез берется от начала до второго индекса; при отсутствии второго индекса, срез берется от первого индекса до конца строки.

\begin{lstlisting}
>>> s = "0123456789";
>>> s[0:2];
'01'
>>> s[:2];
'01'
>>> s[2:];
'23456789'
\end{lstlisting}



\subsection{Операторы сравнения}

%Операторы сравнения обычно используются для сравнения числовых выражений, но в Python они могут применяться и к другим типам данных, например, к множествам, о чем уже было сказано выше. 

Операторы сравнения производят сравнение двух элементов одного класса и в качестве результата возвращают константы True или False. Основные операторы сравнения: равно (\verb|==|), не равно (\verb|!=|), меньше (\verb|<|), больше (\verb|>|), не меньше (\verb|>=|), не больше (\verb|>=|). Например, для числовых типов:

\begin{lstlisting}
>>> 5 <= 3
False
\end{lstlisting}

Кроме того, операторы сравнения перегружены для некоторых других (не числовых) классов. Например, как уже было отмечено выше, применительно к множествам операторы \verb|<| и \verb|>| означают проверку на включение:

\begin{lstlisting}
>>> {1,2,3} > {1,3}
True
\end{lstlisting}

\subsection{Логические операции}

Для переменных логического типа \verb|bool| определены следующие операторы:  \verb|and|, \verb|or| и \verb|and|. Пример использования этих операторов:

\begin{lstlisting}
>>> (not 1==2) or False
True
\end{lstlisting}


\subsection{Преобразование типов данных}

Язык Python допускает неявное преобразование типов. Например, если сложить целое (int) и вещественное (float) числа, то результатом будет число типа \verb|float|:

\begin{lstlisting}
>>> type(3 + 4.5)
<class 'float'>
\end{lstlisting}

Явное преобразование из одного типа в другой имеет следующую форму: \verb|тип(значение)|. Рассмотрим пример преобразования строки в число типа float:

\begin{lstlisting}
>>> float('12'+'3')
123.0

\end{lstlisting}

Еще один полезный пример --- преобразования строки в список символов:

\begin{lstlisting}[caption=Преобразование строки в список символов]
>>> ls = list('string')
>>> ls
['s', 't', 'r', 'i', 'n', 'g']
\end{lstlisting}

% это можно опустить:

Правда, в обратную сторону этот способ (через \verb|str()|) не сработает. Точнее, результат будет не совсем тот, что можно ожидать:

\begin{lstlisting}
>>> str(ls)
"['s', 't', 'r', 'i', 'n', 'g']"
\end{lstlisting}

Для получения исходной строки нужно использовать специальный метод \verb|join()|:

\begin{lstlisting}
>>> ''.join(ls)
'string'
\end{lstlisting}



\subsection{Блоки, циклы и ветвления}

Оператор ветвления представлен единственной условной инструкцией \verb|if|. 

\begin{lstlisting}
if 1 > 2:
	print('условие выполнено')
\end{lstlisting}


В Python отсутствует оператор множественного выбора (switch -- case) как в C++ или JAVA. Для этих целей используется полная конструкция \verb|if|/\verb|elif|/\verb|else|, общая форма которой имеет следующий вид:

\begin{lstlisting}
if <условие1>:
	<блок1>
elif <условие2>:
	<блок2>	
else <условие3>:
	<блок3>	
\end{lstlisting}



Для реализации циклов в Python присутствуют стандартные инструкции \verb|for| и \verb|while|. Инструкция \verb|for| всегда используется в связке с ключевым словом \verb|in| и предназначена для обхода всех элементов списка, множества и любых других последовательностей. Например,

\begin{lstlisting}
for x in {3, 2, 1}:
	print(x)
\end{lstlisting}

Стандартная форма цикла \verb|while| следующая:

\begin{lstlisting}
while <условие>:
	<блок>
\end{lstlisting}

Совместно с инструкциями циклов могут использоваться стандартные инструкции \verb|break| и \verb|continue|, а также менее стандартные инструкции --- \verb|pass| и \verb|else|. Инструкция \verb|pass| --- это пустая инструкция, которая ничего не делает. Инструкция \verb|else| располагается после цикла и всегда выполняется в том случае, если цикл завершается обычном способом (без прерывния с помощью \verb|break|).

Сделаем сразу замечание относительно выделения блоков кода. В отличие от многих других языков программирования, в  Python отсутствуют какие-либо ключевые слова или конструкции для выделения блока (как, например, begin...end в языке Паскале или фигурные скобки в C++). Вместо этого используются горизонтальные отступы для того, чтобы дать понять интерпретатору, где заканчивается данный блок. Например,

\begin{lstlisting}
for x in [1, 2]:
	print(x)
	print(x^2)
print(x^3)
\end{lstlisting}

В этом примере 2-ая и 3-я строки кода включены в тело цикла for и поэтому будут выполнены дважды (для x=1 и x=2), а инструкция 4-ой строки расположена после окончания цикла, и значит выполнится только один раз (для x=2).

Для формирования последовательностей чисел с заданным шагом существует функция \\
\verb|range(start, stop, step)|. Если \verb|step>0|, то она возвращает возврастающую последовательность чисел с условием 

\verb|start <= start + i * step < stop|, 

где i --- целое неотрицательное число. Например, 

\begin{lstlisting}
>>> list(range(0, 10, 2))
[0, 2, 4, 6, 8]
\end{lstlisting}


Функция range часто используется в циклах. Например, следующий код напечатает в консоль последовательность чисел 0, 2, 4, 6, 8.

\begin{lstlisting}
for x in range(0, 10, 2):
	print(x)
\end{lstlisting}

Кроме того, \verb|range| вместе с \verb|for| часто используются для генерации списков (или других последовательностей), что демонстрирует следующий пример:

\begin{lstlisting}
>>> [x**2 for x in range(0, 10, 2)]
[0, 4, 16, 36, 64]
\end{lstlisting}



\subsection{Функции}

Как и в большинстве языков программирования, в Python можно определять собственные функции. Для создания функции предназначена5 инструкция \verb|def|. Ниже показан пример определения функции:

\begin{lstlisting}[caption=Пример объявления функции]
def sum(x,y):
	return x+y
\end{lstlisting}

По умолчанию все переменные внутри функции локальные, т.е. находится в локальной области видимости. Это вполне естественный подход. Однако есть возможность обратиться и к глобальным переменным, объявленным вне функции. Для этого имеются ключевые слова \verb|global| и \verb|nonlocal|.

Еще одни способ задания функций --- использование лямбда-нотации:

\begin{lstlisting}
>>> sum = lambda x,y: x+y
>>> sum(2,3)
5
\end{lstlisting}

Или даже так, без присвоения имени функции:

\begin{lstlisting}
>>> (lambda x,y: x+y)(2,3)
5
\end{lstlisting}

Такие анонимные (или лямбда-функции) составляют основу функционального программирования.


\subsubsection{Передача параметров по ссылке/по значению} Все параметры передаются по ссылке. Однако если переменная связана с неизменяемым значением, например int, str, tulpe, то естественно, это значение не изменится. А вот если переменная связана со списком, словарем или классом, то значение связанного с переменной объекта изменится.



\subsection{Ввод-вывод}

Для считывания строки с консоли используется функция \verb|input|, а для вывода на консоль --- функция \verb|print|.

\begin{lstlisting}
>>> str = input() # ввод строки с консоли
5
>>> x = int(str)  # преобразование в числовую форму
>>> y = x**2
>>> print(y)      # вывод на консоль
25
\end{lstlisting}

Чтение/запись данных из файла можно проводить с помощью методов \verb|read()| и \verb|write()| соответственно. Перед началом работы с файлом его необходимо открыть с помощью функции \verb|open()|, а после окончания работы --- закрыть посредством \verb|close()|. Типичный пример работы с файлом (в текстовом режиме):

\begin{lstlisting}
>>> f = open('newfile.txt','w') # открытие в режиме записи
>>> f.write('Hello')
5
>>> f.close()
>>> f = open('newfile.txt','r') # открытие в режиме чтения
>>> f.read()
'Hello'
>>> f.close()
\end{lstlisting}



















\newpage

\section{Расширения языка Python. Модули и пакеты}


Начнем однако рассмотрение этого вопроса с библиотеки NumPy, которая обычно используется для работы с матрицами. В частности, она понадобится для задания матриц смежности графов.



\subsection{Модули}

До сих пор рассматривались только функции и классы, входящие непосредственно в ядро языка Python. Их использование не требует подключения каких-либо внешних библиотек. Однако для получения большей функциональности возникает необходимость подключения (импортирования) внешних модулей. Для этого служит ключевое слово \verb|import|. 

Например, модуль \verb|math| содержит набор математических функций (\verb|sqrt|, \verb|abs|, \verb|exp|,  \verb|log|, тригонометрические функции и др.). Чтобы использовать эти функции в своей программе, необходимо импортировать модуль \verb|math|:

\begin{lstlisting}[caption=Использование модуля math]
>>> import math
>>> math.pi		# число пи
3.141592653589793
>>> math.cos(math.pi)  # вычисляем косинус числа пи
-1.0
\end{lstlisting}

При импорте модуля можно задать для него псевдоним (исключительно для удобства) с помощью ключевого слова \verb|as|, что позволит затем использовать псевдоним при обращении к атрибутам модуля. Например,

\begin{lstlisting}[caption=Использование модуля math]
>>> import math as m
>>> m.cos(m.pi)
-1.0
\end{lstlisting}

Часто полезно импортировать не весь модуль, а лишь отдельные его атрибуты (имена функций, классов и т.п.). Для этого служит инструкция \verb|from|. Кроме того, после такого импорта для вызова функции достаточно указать только ее имя (без имени модуля):

\begin{lstlisting}
>>> from math import cos, pi
>>> pi
3.141592653589793
>>> cos(pi)
-1.0
\end{lstlisting}

Существуют специальная форма инструкции from, которая позволяет импортировать сразу все атрибуты модуля:

\begin{lstlisting}
>>> from math import *
\end{lstlisting}

Однако такой подход не всегда оправдан, так как часто приводит к <<замусориванию>> пространства имен.

%Инструкции импорта не обязательно должны находится в начала всей программы, они могут идти непосредственно перед первым использованием требуемых функций.

Фактически модули в Python представляют собой просто файлы с исходным кодом либо байт-кодом (причем не обязательно написанных на языке Python). Несколько модулей могут быть помещены в отдельный каталог. Такой каталог называет пакетом. При этом полный путь к функции будет выглядеть примерно так: \verb|пакет.модуль.функция|.

Замечание. Для сравнения, в C++ для доступа к методу класса используется оператор точка, а для доступа к функциям библиотек --- оператор двойного двоеточия (\verb|::|). В Python нет существенной  разницы между модулями и классами, и поэтому в обоих случаях используется оператор точка.




\subsection{NumPy}

Библиотека NumPy расширяет возможности языка Python и предназначена для работы с матрицами (класс \verb|matrix|) и другими объектами линейной алгебры, в частности обеспечивает поддержку больших многомерных массивов (класс \verb|ndarray|). По сути библиотека NumPy представляет собой пакет (набор) модулей, где каждый модуль --- это отдельный файл. Библиотека не входит в стандартный набор, поставляемый с интерпретатором Python, и поэтому требует отдельной установки.

Начнем с рассмотрения матриц. Следующий пример демонстрирует создание матрицы размера 2 на 2 и ее вывода на консоль.

\begin{lstlisting}
>>> import numpy as np
>>> A = np.matrix([[1,2],[3,4]])
>>> print(A)
[[1 2]
 [3 4]]
\end{lstlisting}

С точки зрения ООП написанное здесь можно понимать следующим образом. Во второй строчке происходит создание экземпляра класса matrix (из пакета numpy), причем в конструктор класса передаем стандартный ``питоновский'' список, из которого и формируется ``матрица'' \verb|A|.

После того, как матрица создана, над ней можно производить различные операции. Например, можно вычеслить квадрат этой матрицы:

\begin{lstlisting}
>>> B = A**2
>>> print(B)
[[ 7 10]
 [15 22]]
\end{lstlisting}

Заметим, что для новой матрицы $B$ нет необходимости явно вызывать конструктор. Он будет вызыван автоматически.

Аналогичным образом можно перемножать, складывать и вычитать матрицы, а также умножать матрицы на числа и т.п. (все эти операции уже перегружены в классе matrix).

Для более сложных вычислений над матрицами, например нахождения обратной матрицы, необходимо импортировать модуль \verb|linalg| пакета \verb|numpy|, либо отдельные фукнции из него. Например,

\begin{lstlisting}
>>> from numpy.linalg import inv
>>> print(inv(A))  # вычисление обратной матрицы
[[-2.   1. ]
 [ 1.5 -0.5]]  
\end{lstlisting}

%Полным именем этой функции было бы  \verb|numpy.linalg.inv|, т.е. сначала указывается имя пакета (библиотека numpy), затем имя модуля (т.е. файла) в этого пакете, и затем имя функции.


\subsubsection{Класс ndarray} 

Как уже было сказано, \textbf{NumPy} реализует поддержку больших многомерных массивов. Класс многомерных массивов называется \verb|ndarray|. (Он отличается от класса \verb|array| стандартной библиотеки Python, который используется только для одномерных массивов).

Пример: 
\begin{verbatim}
[[ 1., 0., 0.],
[ 0., 1., 2.]] 
\end{verbatim}

Атрибуты объектов ndarray:

\begin{itemize}
\item ndarray.ndim --- число осей (измерений) массива;
\item ndarray.shape --- размеры массива, его форма;
\item ndarray.size --- число всех элементов массива;
\item ndarray.dtype --- объект, описывающий тип элементов массива;
\item ndarray.itemsize --- размер каждого элемента массива в байтах.
\item ndarray.data --- буфер, содержащий фактические элементы массива;
\end{itemize}


\vspace{3mm}

\verb|array()| --- функция, создающая объект типа \verb|ndarray| --- эта функция трансформирует вложенные последовательности в многомерные массивы:

По умолчанию тип создаваемого массива --- \verb|float64|. Но его можно изменить с помощью \verb|dtype|.

\begin{lstlisting}[caption=Создание массивов]
import numpy as np
a = np.array([1, 2, 3])
b = np.array([[1.5, 2, 3], [4, 5, 6]])
c = np.array([[1.5, 2, 3], [4, 5, 6]], dtype=np.complex)
\end{lstlisting}

Стандартные массивы:

\begin{itemize}
\item np.zeros((nx, ny)) --- создает массив из нулей,
\item np.ones((nx, ny, nz)) --- массив из единиц.
\item eye(n) --- единичная матрица (двумерный массив);
\item empty() --- массив без заполнения;
\end{itemize}

\verb|arange()| --- для создания последовательностей чисел (аналогична встроенной функции \verb|range()|, только вместо списков она возвращает массивы).

\begin{lstlisting}[caption=Последовательности]
np.arange(10, 30, 5)
array([10, 15, 20, 25])
\end{lstlisting}


\subsection{Графическая библиотека matplotlib}

\verb|Matplotlib| --- это библиотека двумерной графики для Python, которая позволяет создавать высококачественные рисунки различных форматов. В последних версиях включена также поддержка трехмерной графики. Библиотека позволяет выводить на экран различные графические примитивы, такие как графики функций, гистограммы и т.п. По сути это объектно-ориентированное API над графическими библиотеками wxPython, Qt и GTK+.

Рассматриваемые ниже библиотеки для работы с графами используют внутри себя функции из Мatplotlib для формирования изображений графов. Явно нам понадобится вызывать только функцию \verb|show()| этой библиотеки, если мы хотим вывести рисунок на экран, либо функцию \verb|savefig()| для сохранения рисунка в файл.





\newpage


\section{Библиотеки Python для работы с графами}

Здесь дан обзор некоторых инструментов, позволяющих упростить работы с графами на языке Python. Под Python существует несколько библиотек для работы с графами. Основные из них --- это networkx, igraph, graph-tool. Первые две библиотеки просты в освоении, однако их применение ограничивается в основном визуализацией (построением) графов. Библиотека graph-tool обладает гораздо большими возможностями, поскольку в ней уже реализованы базовые алгоритмы на графов. Однако в учебных целях достаточно библиотек networkx и igraph.

\subsection{Библиотека networks}

%link: http://bl.ocks.org/rkirsling/5001347

Веб-сайт проекта: https://networkx.github.io/

Пакет \verb|networkx| представляет собой мощное средство для работы с различными сетевыми структурами (графами, диаграмами и т.п.), включая их создание, изучение структуры, проведение различных манипуляций, и визуализация. С помощью этой библиотеки можно легко построить граф и вывести его на экран.

\begin{lstlisting}[caption=Рисуем граф]
import networkx as nx
import matplotlib.pyplot as plt
nodes = ['A','B','C','D','E']  # список вершин
edges = [('A','B'), ('A','C'), ('D','B'), ('E','C'), 
	('E','D'), ('B','E'), ('C','D')] # список ребер
G = nx.Graph()           # создаем нулевой граф
G.add_nodes_from(nodes)  # добавляем в него вершины
G.add_edges_from(edges)  # добавляем ребра
nx.draw(G, with_labels = True, node_color = 'b')  # отрисовка графа
plt.show() # вывод изображения на экран
\end{lstlisting}

Здесь следует пояснить, что в 6-ой строке создается экземпляр класса Graph. 

Пакет \verb|matplotlib| нужен для вывода изображения на экран. В результате будет посроен граф, показанный на рисунке \ref{fig:nx}.

\begin{figure}[h] %http://mydebianblog.blogspot.com.by/2008/12/latex_15.html
\includegraphics[width=0.5\textwidth]{pict/pict_networkx_2.eps}
\caption{Построение графа с помощью networkx}
\label{fig:nx}
\end{figure}


При желании вместо вывода на экран изображение графа можно сохранить в файл:
\begin{lstlisting}
plt.savefig("graph.png")
\end{lstlisting}

Атрибут \verb|node_color| задает цвет вершин. В приведенном выше примере был задан общий цвет для всех вершин графа (в данном случае синий --- 'b'). Однако есть возможность задать индивидуальный цвет для каждой вершины. Для этого нужно атрибуту \verb|node_color| присвоить список цветов, например,
\begin{lstlisting}
node_color = ['r','g','b','w','y']
\end{lstlisting}

Класс \verb|Graph| пакета networks соответствует неориентированному графу. Если требуется построить орграф, то нужно использовать класс \verb|DiGraph|, т.е. вызвать
\begin{lstlisting}
G = nx.DiGraph()  
\end{lstlisting}
(остальной код останется неизменным)

Рассмотрим следующую задачу. Требуется построить граф по заданной матрице смежности. Для этих целей в пакете \verb|networkx| имеется функция \verb|from_numpy_matrix()|. Ниже приведен требуемый код программы. 

\begin{lstlisting}[caption=Строим граф по матрице смежности]
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
A = np.matrix([
[0,1,1,0,1],
[1,0,1,0,0],
[1,1,0,1,1],
[0,0,1,0,1],
[1,0,1,1,0] ])
G = nx.from_numpy_matrix(A) # строим граф по матрице смежности
nx.draw(G, with_labels = True)
#plt.savefig("simple_path.png") # save as png
plt.show() # display
\end{lstlisting}

%Для создания матрицы мы использовали библиотеку \verb|numpy|, рассмотренную выше.        

Пакет \verb|networkx| поддерживает также возможность работы с ориентированными графами:

\begin{lstlisting}
G = nx.from_numpy_matrix(A, create_using=nx.MultiDiGraph())
\end{lstlisting}


%------------


\subsection{Библиотека python-igraph}

igraph --- еще одна библиотека, предназначенная для работы с графами и сетями. Реализации этой библиотеки доступныа на разных языках, включая Python, R и C/C++. Библиотека еще находится в стадии разработки. Она не входит в стандартные репозиторий ОС Linux, и поэтому требует ручной установки. Страница проекта в Интернете http://igraph.org.


Установка библиотеки включает следующие шаги.

1) Скачать архив с сайта: \verb|https://pypi.python.org/pypi/python-igraph#downloads|

2) Распакавать архив.

3) Выполнить установку: \verb|sudo python3 setup.py install|


По сути библиотека igraph мало чем отличается от библиотеки networkx. Мы не будем останавливаться на ней подробно. Приведем лишь небольшой пример, демонстрирующий построения графа с помощью igraph.

\begin{lstlisting}[caption=Строим граф с помощью библиотеки igraph]
from igraph import *
G = Graph()       # создаем граф
G.add_vertices(3) # добавляем 3 вершины
G.add_edges([(0,1), (1,2), (2,0)]) # добавляем ребра
G.vs["label"] = ["A","B","C"]  # присваиваем метки вершинам
plot(G)           # выводим граф на экран
\end{lstlisting}


\subsection{Библиотека graph-tool}

Библиотека graph-tool --- это пакет модулей, предназначенный для статического анализа графов. Сама библиотека написана на языке C++, что обеспечивает высокую производительность. В отличие от предыдущих двух библиотек здесь уже реализованы некоторые базовые алгоритмы на графах, например алгоритмы поиска и алгоритмы нахождения максимального потока. Однако мы не будем разбирать эти возможности библиотеки, поскольку в рамках нашего курса эти алгоритмы должны быть реализованы студентами самостоятельно. Поэтому остановимся лишь на базовых возможностях библиотеки graph-tool.

Веб-сайт проекта: https://graph-tool.skewed.de/

https://graph-tool.skewed.de/download

sudo apt-get install python-graph-tool

sudo apt-get install python3-graph-tool


Если этот путь не сработает, то установка через gdebi пакетов отсюда:

http://downloads.skewed.de/apt/jessie/pool/main/p/

Рассмотрим пример построения орграфа с помощью библиотеки graph-tool:

\begin{lstlisting}[caption=Построение орграфа]
from graph_tool.all import *
g = Graph()  # создание объекта типа граф
v0 = g.add_vertex()  # добавление вершин в граф
v1 = g.add_vertex()
v2 = g.add_vertex()
v3 = g.add_vertex()
e1 = g.add_edge(v0, v1) # добавление ребер в граф
e2 = g.add_edge(v1, v2)
e3 = g.add_edge(v1, v3)
e4 = g.add_edge(v2, v0)
e5 = g.add_edge(v2, v3)
graph_draw(g, vertex_text=g.vertex_index, vertex_font_size=18, output_size=(200, 200)) # вывод на экран
\end{lstlisting}

Результат работы программы представлен на рисунке \ref{fig:g-t-1}.

\begin{figure}[h] %http://mydebianblog.blogspot.com.by/2008/12/latex_15.html
\includegraphics[width=0.3\textwidth]{pict/pict_graph-tool.eps}
\caption{Построение ориентированного графа с помощью graph-tool}
\label{fig:g-t-1}
\end{figure}

По умолчанию конструктор класса создает ориентированный граф. Для того, чтобы создать неориентированный граф, необходимо присвоить значение False атрибуту directed:

\begin{lstlisting}
g = Graph(directed=False)
\end{lstlisting}

В библиотеке graph-tool, как и в igraph, отсутсвует готовая функция построения графа по его матрице смежности. Следующий код решает эту проблему:

\begin{lstlisting}[caption=Задание графа матрицей смежности]
import numpy as np
import graph_tool
from graph_tool.all import graph_draw
W = np.matrix([ 
	[0.0, 0.0, 8.5], 
	[1.3, 0.0, 0.0], 
	[0.0, 2.0, 0.0]])
num_vertices = W.shape[0]
g = graph_tool.Graph(directed = True)
g.add_vertex(num_vertices)
label_weight = g.new_edge_property('string')

for i in range(0, num_vertices):
	for j in range(0, num_vertices):
		if W[i,j] != 0:
			print("i=" + str(i) + ", j=" + str(j))
			e = g.add_edge(i, j)
			label_weight[e] = str(W[i,j])

graph_draw(g, vertex_text=g.vertex_index, edge_text=label_weight, vertex_font_size=20, edge_font_size=20, output_size=(300, 300))  
\end{lstlisting}

Результат показан на рисунке \ref{fig:g-t-2}.

\begin{figure}[h] %http://mydebianblog.blogspot.com.by/2008/12/latex_15.html
\includegraphics[width=0.25\textwidth]{pict/pict_graph-tool_weigh_graph.eps}
\caption{Построение нагруженного графа с помощью graph-tool}
\label{fig:g-t-2}
\end{figure}




\begin{thebibliography}{10}

\bibitem{Lutc} Лутц, М. Изучаем Python / М. Лутц. --- 4-ое изд. --- Пер. с англ. --- СПб.: Символ-Плюс, 2011. --- 1280 с.




\end{thebibliography}

\end{document} 

