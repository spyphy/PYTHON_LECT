\input{_head.tex}
\newif\ifFULL
\FULLtrue

\begin{document}
\footskip=30pt
\date{}
\title{GUI}
\maketitle
\pagestyle{plain}
%\fontsize{13}{14pt}\selectfont   
%\fontsize{11}{12pt}\selectfont   
\setcounter{secnumdepth}{2}  % turn off numeration of sections
\input{styles/style_python.tex}


\section{NumPy}

{\bf NumPy} (Numerical Python) пакет для высокопроизводительных вычислений, предназначенный для работы с большими многомерными массивами данных (класс \verb|ndarray|), а также с объектами линейной алгебры, в частности матрицами (класс \verb|matrix|). 

Библиотека требует отдельной установки:
\verb|sudo pip3 install numpy|

Основные классы, содержащиеся в библиотеке Numpy.
\begin{itemize}
 \item \verb|ndarray| -- многомерный массив; создаются с помощью функции array;
 \item \verb|matrix(numpy.ndarray)| -- матрицы; создаются с помощью matrix, mat или asmatrix;
\end{itemize}

Пакеты, входящие в состав Nympy:
\begin{itemize}
 \item \verb|numpy.random| -- содержит ряд функций для генерации случайных чисел, например, random(), rand(), randn(), randint() и др.
 \item \verb|numpy.matlib| --- 
\end{itemize}



\subsection{Класс ndarray}$~$

Как уже было сказано, \textbf{NumPy} реализует поддержку больших многомерных массивов. Класс многомерных массивов называется \verb|ndarray|. (Он отличается от класса \verb|array| стандартной библиотеки Python, который используется только для одномерных массивов).

Пример: 
\begin{verbatim}
[[ 1., 0., 0.],
[ 0., 1., 2.]] 
\end{verbatim}

Атрибуты объектов ndarray:

\begin{itemize}
\item ndarray.ndim --- число осей (измерений) массива;
\item ndarray.shape --- размеры массива, его форма;
\item ndarray.size --- число всех элементов массива;
\item ndarray.dtype --- объект, описывающий тип элементов массива;
\item ndarray.itemsize --- размер каждого элемента массива в байтах.
\item ndarray.data --- буфер, содержащий фактические элементы массива;
\end{itemize}


\vspace{3mm}

\verb|array()| --- функция, создающая объект типа \verb|ndarray| --- эта функция трансформирует вложенные последовательности в многомерные массивы:

По умолчанию тип создаваемого массива --- \verb|float64|. Но его можно изменить с помощью \verb|dtype|.

\begin{lstlisting}[caption=Создание массивов]
import numpy as np
a = np.array([1, 2, 3])
b = np.array([[1.5, 2, 3], [4, 5, 6]])
c = np.array([[1.5, 2, 3], [4, 5, 6]], dtype=np.complex)
\end{lstlisting}

Стандартные массивы:

\begin{itemize}
\item np.zeros((nx, ny)) --- создает массив из нулей,
\item np.ones((nx, ny, nz)) --- массив из единиц.
\item eye(n) --- единичная матрица (двумерный массив);
\item empty() --- массив без заполнения;
\end{itemize}

\verb|arange()| --- для создания последовательностей чисел (аналогична встроенной функции \verb|range()|, только вместо списков она возвращает массивы).

\begin{lstlisting}[caption=Последовательности]
np.arange(10, 30, 5)
array([10, 15, 20, 25])
\end{lstlisting}




\subsection{Matrix}

Начнем с рассмотрения матриц. Следующий пример демонстрирует создание матрицы размера 2 на 2 и ее вывода на консоль.

\begin{lstlisting}
>>> import numpy as np
>>> A = np.matrix([[1,2],[3,4]])
>>> print(A)
[[1 2]
 [3 4]]
\end{lstlisting}

С точки зрения ООП написанное здесь можно понимать следующим образом. Во второй строчке происходит создание экземпляра класса matrix (из пакета numpy), причем в конструктор класса передаем стандартный ``питоновский'' список, из которого и формируется ``матрица'' \verb|A|.

После того, как матрица создана, над ней можно производить различные операции. Например, можно вычеслить квадрат этой матрицы:

\begin{lstlisting}
>>> B = A**2
>>> print(B)
[[ 7 10]
 [15 22]]
\end{lstlisting}

Заметим, что для новой матрицы $B$ нет необходимости явно вызывать конструктор. Он будет вызыван автоматически.

Аналогичным образом можно перемножать, складывать и вычитать матрицы, а также умножать матрицы на числа и т.п. (все эти операции уже перегружены в классе matrix).

Для более сложных вычислений над матрицами, например нахождения обратной матрицы, необходимо импортировать модуль \verb|linalg| пакета \verb|numpy|, либо отдельные фукнции из него. Например,

\begin{lstlisting}
>>> from numpy.linalg import inv
>>> print(inv(A))  # вычисление обратной матрицы
[[-2.   1. ]
 [ 1.5 -0.5]]  
\end{lstlisting}

%Полным именем этой функции было бы  \verb|numpy.linalg.inv|, т.е. сначала указывается имя пакета (библиотека numpy), затем имя модуля (т.е. файла) в этого пакете, и затем имя функции.





\section{Графическая библиотека matplotlib}

\verb|Matplotlib| --- это библиотека двумерной графики для Python, которая позволяет создавать высококачественные рисунки различных форматов. В последних версиях включена также поддержка трехмерной графики. Библиотека позволяет выводить на экран различные графические примитивы, такие как графики функций, гистограммы и т.п. По сути это объектно-ориентированное API над графическими библиотеками wxPython, Qt и GTK+.

Рассматриваемые ниже библиотеки для работы с графами используют внутри себя функции из Мatplotlib для формирования изображений графов. Явно нам понадобится вызывать только функцию \verb|show()| этой библиотеки, если мы хотим вывести рисунок на экран, либо функцию \verb|savefig()| для сохранения рисунка в файл.


\begin{lstlisting}
import matplotlib.pyplot as plt
import numpy as np

lag = 0.1
x = np.arange(0.0, 2*np.pi+lag, lag)
y = np.cos(x)

fig = plt.figure()
plt.plot(x, y)

plt.text(np.pi-0.5, 0,  '1 Axes', fontsize=26, bbox=dict(edgecolor='w', color='w'))
plt.text(0.1, 0, '3 Yaxis', fontsize=18, bbox=dict(edgecolor='w', color='w'), rotation=90)
plt.text(5, -0.9, '2 Xaxis', fontsize=18, bbox=dict(edgecolor='w', color='w'))

plt.title('1a TITLE')
plt.ylabel('3a Ylabel')
plt.xlabel('2a Xlabel ')

plt.text(5, 0.85, '6 Xticks', fontsize=12, bbox=dict(edgecolor='w', color='w'), rotation=90)
plt.text(0.95, -0.55, '6 Xticks', fontsize=12, bbox=dict(edgecolor='w', color='w'), rotation=90)

plt.text(5.75, -0.5, '7 Yticks', fontsize=12, bbox=dict(edgecolor='w', color='w'))
plt.text(0.15, 0.475, '7 Yticks', fontsize=12, bbox=dict(edgecolor='w', color='w'))

plt.grid(True)

# смотри преамбулу
save('pic_1_5_1', fmt='pdf')
save('pic_1_5_1', fmt='png')

plt.show()
\end{lstlisting}



%---------------------------
\section{Pandas. Data analysis}

ipython+pandas+mathplotlib = замена R для знающих Python. 


\subsection{Some examples. Traiding alalysis}
\url{https://www.datacamp.com/community/tutorials/finance-python-trading}

\begin{verbatim}
sudo pip3 install pandas_datareader 
sudo pip3 install quandl  
\end{verbatim}

Get data from yahoo:
\begin{lstlisting}
import pandas_datareader as pdr
import datetime 
aapl = pdr.get_data_yahoo('AAPL', start=datetime.datetime(2016, 10, 1), end=datetime.datetime(2017, 1, 1))
\end{lstlisting}

Using Google:
\begin{lstlisting}
import quandl 
aapl = quandl.get("WIKI/AAPL", start_date="2006-10-01", end_date="2012-01-01")
\end{lstlisting}

Информация о данных:
\begin{lstlisting}
aapl.describe()
aapl.head()
aapl.tail()
aapl.index
aapl.columns
\end{lstlisting}


Сохранение в формате csv:

\begin{lstlisting}
import pandas as pd
aapl.to_csv('aapl_ohlc.csv')
df = pd.read_csv('aapl_ohlc.csv', header=0, index_col='Date', parse_dates=True)
\end{lstlisting}

\begin{lstlisting}
import matplotlib.pyplot as plt

# Plot the closing prices for `aapl`
aapl['Close'].plot(grid=True)

# Show the plot
plt.show()
\end{lstlisting}

Analysis:
\begin{lstlisting}
# Assign `Adj Close` to `daily_close`
daily_close = aapl[['Adj Close']]

# Daily returns
daily_pct_change = daily_close.pct_change()

# Replace NA values with 0
daily_pct_change.fillna(0, inplace=True)

# Inspect daily returns
print(daily_pct_change)

# Daily log returns
daily_log_returns = np.log(daily_close.pct_change()+1)

# Print daily log returns
print(daily_log_returns)


# Resample `aapl` to business months, take last observation as value 
monthly = aapl.resample('BM').apply(lambda x: x[-1])

# Calculate the monthly percentage change
monthly.pct_change()

# Resample `aapl` to quarters, take the mean as value per quarter
quarter = aapl.resample("4M").mean()

# Calculate the quarterly percentage change
quarter.pct_change()


# Daily returns
daily_pct_change = daily_close / daily_close.shift(1) - 1

# Print `daily_pct_change`
print(daily_pct_change)
\end{lstlisting}

Построение гистограмм:
\begin{lstlisting}
# Import matplotlib
import matplotlib.pyplot as plt

# Plot the distribution of `daily_pct_c`
daily_pct_change.hist(bins=50)

# Show the plot
plt.show()

# Pull up summary statistics
print(daily_pct_change.describe())
\end{lstlisting}


\subsection{Series}$~$

\verb|Series| --- объект, содержащий одномерный numpy-массив данных. Отличительной чертой является наличие ассоциированных меток, т.н. индексов, вдоль каждого элемента из списка. 
\begin{lstlisting}
import pandas as pd
from pandas import Series
s = pd.Series([5, 6, 7, 8, 9, 10])
>>> s.value
>>> s.index
\end{lstlisting}

\subsection{DataFrame}$~$

\verb|DataFrame| --- аналог data.frame языка R. Представляет собой таблицу, в которой столбцами в объекте DataFrame выступают объекты Series.

На вход подаются данные в виде словаря, где ключи --- это названия столбцов, а значения словаря --- список значений столбца.
\begin{lstlisting}
import pandas as pd
from pandas import DataFrame
data = {'Name': ['Vasya', 'Dmitry', 'Petya'], 'Age': [20, 30, 22]}
df = DataFrame(data)
\end{lstlisting}

Задать порядок столбцов:
\begin{lstlisting}
df = DataFrame(data, columns = ['Name', 'Age'])
\end{lstlisting}

По умолчанию индексы --- 0, 1, 2,... Можно задать другие индексы: \verb|index=['one','two']|

\vspace{3mm}

Общая статистика:
\begin{lstlisting}
df.describe()
dir(df)
\end{lstlisting}

Больше статистики:
\begin{lstlisting}
data = {'Name': ['Vasya', 'Dmitry', 'Petya'], 'Mark': [7.2, 8.2, 9.0], 'IQ': [100, 120, 119]}
df = DataFrame(data)
df.mean()
df.std()
df.corr()
df.cov()
\end{lstlisting}



\end{document} 


