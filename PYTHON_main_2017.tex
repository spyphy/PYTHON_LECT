\input{_head.tex}
\newif\ifFULL
\FULLtrue

\begin{document}
\footskip=30pt
\date{}
\title{Phyton и теория графов}
\maketitle
\pagestyle{plain}
%\fontsize{13}{14pt}\selectfont   
%\fontsize{11}{12pt}\selectfont   
\setcounter{secnumdepth}{3}  % turn off numeration of sections
\input{styles/style_python.tex}

\setcounter{tocdepth}{4}
\tableofcontents 


\section{INSTALL: Приложение А. Установка интерпретатора Python и библиотек для него}

link: http://pythonicway.com/python-data-types

http://pep8.ru/doc/dive-into-python-3/4.html

\begin{verbatim}
sudo apt-get install python				  # установка интерпретатора Python
sudo apt-get install python-numpy		  # библиотека numpy	
sudo apt-get install python-matplotlib   # is a python 2D plotting library
sudo apt-get install python-serial   	  # com-port
sudo apt-get install python-networkx
\end{verbatim}

Аналогично для python3:
\begin{verbatim}
sudo apt-get install python3-numpy
sudo apt-get install python3-matplotlib
sudo apt-get install python3-serial
sudo apt-get install python3-networkx
\end{verbatim}

2008 г. ---  вышла первая версия Python 3.0 (Py3k). Но до сих пор активно используется также ветка 2.x. Для запуска интерпретатора Python 3 нужно явно писать 

\verb|python3|

иначе будет запущен интерпретатор Python 2.



Скрипт на питоне должен начинаться со строк

\begin{lstlisting}
#!/usr/bin/python # или python3
#coding=utf-8     # или другая кодировка
\end{lstlisting}

Модули и библиотеки для научных расчетов:

\begin{itemize}
\item \textbf{NumPy} --- линейная алгебра (матрицы, вектора, полиномы, СЛАУ и др.).
\item \textbf{SymPy} ---  символьные вычисления: лин. алгебра, геометрия, статистика, отображение трехмерных поверхностей. Весит около 1 Гб.
\item \textbf{Matplotlib} --- это библиотека для построения графиков и визуализации данных. 
\item \textbf{Dislin} --- это многоязыковая библиотека для построения графиков.
\end{itemize}

\subsection{Различия Python2 и Python3}$~$

1) Строки.

2) Функция \verb|input()| из Python3 = \verb|raw_input()| из Python2.

При этом \verb|input()| из Python2 = \verb|eval(raw_input())|.



\section{Краткая справка по языку Python}



\subsection{Полезные функции}$~$

\verb|exec(obj[, globals[, locals]])| --- динамически исполняет указанный код. Здесь obj --- cтрока кода, либо объект кода.


\verb|eval(expression, globals=None, locals=None)| --- разбирает и исполняет указанное выражение. Возвращает какой-то результат.

Например, \verb|x = 1; eval('x+1')|.

Функциям eval() и exec() можно передавать результаты функций globals() и locals().


\subsection{Типы данных в Phyton}$~$



В Phyton используется {\bf динамическая типизация}, т.е. тип данных определяется автоматически при присвоении значения переменной.

Присвоение значения осуществляется с помощью знака равенства (\verb|=|).

\begin{lstlisting}[caption=Присвоить значение переменной]
age = 23 # Присвоение значения 23 переменной age 
print age
country = "Swiss" 
print country
\end{lstlisting}


К стандартным типам данных в Python относят: 
\begin{itemize}
\item Числа (Numbers):~~ \verb|int, long, float, complex|;
\item Строка (String):~~~~ \verb|str = "Hello"| ~~либо~~ \verb|str = 'Hello'|;
\item Множество (Set):~~~~~~~ \verb|A ={1,2,3}|;
\item Список (List):~~~~~~~ \verb|lst =[True, 786, 3.14, 'text', 70.2]|;
\item Кортеж (Tuple):~~~~ \verb|tup =(True, 786, 3.14, 'text', 70.2);|
\item Словарь (Dictionary) ---  неотсортированная колекция элементов, доступ к которым осуществляется по ключу.
\end{itemize}

Преобразование типов данных: 
\begin{verbatim}
int(x [,base]), long(x [,base] ), float(x), complex(real [,imag]), 
str(x), tuple(s), list(s), dict(d)|;
\end{verbatim}


\subsection{Списки}$~$

\begin{lstlisting}[caption=Списки]
A = [1, 3, 3, 2]
B = [a*a for a in A]   # cписковое включение
print(A)   # [1, 3, 3, 2]
print(B)   # [1, 9, 9, 4]
\end{lstlisting}


\subsection{Кортежи}$~$

\begin{lstlisting}[caption=Кортежи]
A = (1, 3, 3, 2)
\end{lstlisting}



\subsection{Множества}$~$

\begin{lstlisting}[caption=Множества]
A = {1, 3, 3, 2}
B = [a*a for a in A]
print(A)   # {1, 2, 3}
print(B)   # [1, 4, 9]
\end{lstlisting}


\subsection{Строки}$~$

Можно использовать апострофов либо кавычки. Оба варианта эквивалентны:

\begin{lstlisting}[caption=Строки]
s = 'python'
s = "python"
\end{lstlisting}

Чаще используется апостроф \verb|'|.

Тройные кавычки используются для записи многострочных блоков текста:
\begin{lstlisting}
text = '''многострочный
	блок текста'''
\end{lstlisting}


\subsubsection{Форматирование строк в стиле printf}$~$
\begin{lstlisting}
format % values
\end{lstlisting}

\begin{lstlisting}[caption=Например]
x = 7
str = 'x=%d' % x            # out: x=7
str = '%d+%d' % (x+1, x+2)  # out: 8+9
str = '%(a)d %(b)d %(a)d' % {'a':x, 'b':x+1}  # out: 7 8 7
\end{lstlisting}



%------------------------------------------

\subsection{Функции}

Объявление функции

\begin{lstlisting}[caption=Пример функции]
def func(x):
	return x*x
y = func(9)
print(y)
\end{lstlisting}

По умолчанию переменные локальные, т.е. находится в локальной области видимости этой функции.

Однако можно обратиться и изменять глобальные переменные, т.е. переменные, объявленные на верхнем уровне модуля.

\begin{lstlisting}[caption=Использование global]
y = 1;
def func():
	global y
	y = 2
func()
print('y =',y) # Result: y = 2
\end{lstlisting}



\subsection{$\lambda$-функции}$~$

Лямбда-функция (или анонимная функция) --- это функция, при определении которой не нужно указывать ее имя. 

\begin{lstlisting}[caption=Пример $\lambda$-функции]
func = lambda x, y: x**2 + y**2
func(2, 3)
\end{lstlisting}

\begin{lstlisting}[caption=Непосредственное использование]
(lambda x: x+2)(5)
\end{lstlisting}


\begin{lstlisting}[caption=Замыкания]
multiplier = lambda n: lambda k: n*k
mul2 = multiplier(2) # mul2 - функция, умножающая на 2
\end{lstlisting}






\section{Python - универсальный язык прикладного программирования}

Язык Python появился в 1991 г. Его синтаксис создавался под влиянием существовавших на то время языков, таких как C++, JAVA, Lisp, ABC и др. Учитывая, что С/С++ являлся наиболее популярным языком системного программирования на тот момент, язык Python проектировался с учетом возможности быстрого освоения Python при наличии базовых знаний С++.

Python -  кросплатформенный интерпретируемый высокоуровневый язык прикладного программирования. В настоящее время основными сферами применения языка Python являются:

- научные вычисления (как полноценная альтернатива MATLAB), для чего в нем есть модули NumPy, SciPy, MatPlotLib;

- веб-разработка (как альтернатива языку PHP), основной фреймворк - Django.

Кроме того, Python успешно справляется со следующими задачами:

- разработка GUI (графического интерфейса пользователя) с помощью модули Tk; также имеется модуль PyQt, который позволяет использовать возможности мощной библиотеки Qt при разработке оконных приложений.

- системы искусственного интеллекта (библиотеки Theano, Keras и др.)




\subsection{Начало работы c Python}

Начинать изучение языка Python проще с примеров. Так, самая простая программа, выводящая на консоль фразу ``Hello World!'', на языке Python состоит всего из одной строки:

\begin{lstlisting}[caption=Первая программа на языке Python]
print('Hello World!')
\end{lstlisting}

В терминологии интерпретируемых языков такая программа называется сценарием. Достаточно сохранить этот сценарий в файл под именем, скажем, prog.py, а затем запустить с помощью интерпретатора языка Python. Будет получен следующим результат:

\begin{lstlisting}
$ python3 prog.py 
Hello World!
\end{lstlisting}

Если в консоли набрать \verb|python3| без параметров, то попадем в так называемый <<интерактивный режим>>. Этот режим удобен на начальной стадии изучения языка, поскольку позволят пошагово выполнять инструкции и тут же наблюдать за результатом:

\begin{lstlisting}
$ python3
Python 3.4.2 (default, Oct  8 2014, 13:14:40) 
[GCC 4.9.1] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> print("Hello World!")
Hello World!
>>> 
\end{lstlisting}

%Интерактивный режим удобен при изучении языка и проверки его основных возможностей. Поэтому этим режимом мы будем часто пользоваться.

%Замечание: Команда \verb|python| по умолчанию запускает интерпретатор языка Python версии 2. Для запуска 3-ей версии нужно указывать это явно --- \verb|python3|.  Впрочем это может зависеть от настроек ОС.

Комментарии могут быть добавлены в текст программы после символа \#:

\begin{lstlisting}
print('Hello World!') # это комментарий
\end{lstlisting}

Инструкции в Python заканчиваются переводом строки. При этом нет необходимости ставить точку с запятой (как, например, в C++), хотя ее постановка не будет ошибкой. Точка с запятой используется, если возникает необходимость разместить несколько инструкций в одной строке, например
\begin{lstlisting}
>>> x = 2; y = 3; print(x+y)
5
\end{lstlisting}



\subsection{Типы данных}

Python --- язык со строгой динамической типизацией. Строгая типизация означает, что переменная в любой момент времени имеет точно определенный тип. В языке Python тип переменной легко определить с помощью функции \verb|type|:

\begin{lstlisting}[caption=Строгая динамическая типизация]
>>> X = 10
>>> type(X)
<class 'int'>
>>> X = 'Hello'
>>> type(X)
<class 'str'>
\end{lstlisting}

Здесь знак <<равно>> (\verb|=|) --- оператор присваивания. Это аналогично синтаксису языков C/C++/JAVA. Однако в отличие от них, в Python нет необходимости объявлять тип переменной. Он определяется автоматически в ходе выполнения программы (динамическая типизация. Более того, переменная может изменить свой тип в ходе выполненения программы, если ей будет присвоено новое значение другого типа. Как говорят, в языке Python <<важнее значение, а не имя переменной>>. Удобство такого подхода проявится, например, при написании функции. Таким образом, имена переменных в Python --- это только ссылки на объекты. Они не хранят информацию о типе объекта.

К основным встроенныем типам данных языка Python относятся числа, строки, множества, списки, кортежи и словари. Рассмотрим их подробнее (в скобках будет указан тип данных, возвращаемый функцией \verb|type|). 

\begin{itemize}
\item Числовые типы, которые включают целые (\verb|int| и \verb|long|), вещественные (\verb|float|) и комплексные (\verb|complex|) числа.

\item Строка (\verb|str|) --- последовательность символов Юникода. Строки заключаются в кавчики либо в апострафы (оба варианта равноценны). Например, \verb|"Python"| или \verb|'Python'|.

\item Множество (\verb|set|). Пример множества: \verb|{1,2,3}|.

\item Список (\verb|list|) --- упорядоченная последовательность значений произвольных типов. Пример списка: \verb|[1,2,3]|.

\item Кортежь (\verb|tuple|) --- тоже список, только неизменяемый. Пример кортежа: \verb|(1,2,3)|.

\item Словарь (\verb|dict|) ---  неотсортированная колекция элементов, доступ к которым осуществляется по ключу. Пример словаря: \verb|{1:'a', 2:'b'}|. По большому счету словарь в Python --- это список кортежей.

\item Логический тип (\verb|bool|), переменные которого могут принимать только два значения: \verb|True| и \verb|False|.
\end{itemize}

В Python все типы данных реализованы в виде объектов, причем для них наиболее важные операторы уже перегружены. Поэтому работат с базовыми типами можно двумя способами: либо посредством вызова методов объектов, либо использовать перегруженные операторы. 

Продемонстрируем сказанное на примере класса \verb|int|, реализующего целые числа. Для этого класса перегружены базовые операторы \verb|+|,\verb|-|,\verb|*|, \verb|/| и \verb|**| (возвещение в степень), соответствующие основные арифметическим операция. Например, код

\begin{lstlisting}
>>> 2+3
5
\end{lstlisting}

может быть записан в эквивалентном виде с использованием метода \verb|__add__()| класса \verb|int|:

\begin{lstlisting}
>>> (2).__add__(3)
5
\end{lstlisting}

Но, конечно, так никто не пишет.

Узнать полный список методов любого класса можно посредством функции \verb|dir|, указав нужный класс в качестве аргумента этой функции. Например,

\begin{lstlisting}
>>> dir(int)
\end{lstlisting}

Для получения более детальной справки о классе и его методах используйте функцию \verb|help|:

\begin{lstlisting}
>>> help(int)
>>> help(int.__add__)
\end{lstlisting}


Среди полезных возможностей Python следует отметим возможность работы с комплексными числами. Мнимая единица задается как \verb|1j| либо \verb|1J|. Например, 

\begin{lstlisting}
>>> 1j*1j
(-1+0j)
\end{lstlisting}

Кроме того, существует модуль \verb|fractions|, который поддерживает работу с рациональными дробями, однако мы не будем его здесь рассматривать.
%Однако его здесь рассматривать не будем. Вместо этого перейдем к обзору более сложных типов данных и операций над ними.

\subsection{Списки}

Списки в Python --- это аналог массивов из других языков программирования. Поэтому они используются довольно часто. Списки в Python задаются в виде последовательности элементов, перечисленных через запятую и заключенных в квадратные скобки с обоих сторон. При этом элементы списка могут иметь любой тип (не обязательно одинаковый), в частности, они могут быть тоже списками. Рассмотрим некоторые часто используемые операции над списками.

Получить элемент списка можно, указав его номер в квадратных скобках после имени списка: 

\begin{lstlisting}
L = [1, 2, 'A', True, [3, 4]]
>>> L[0]     # первый элемента списка
1
>>> L[4][0]  # извлекаем элемент вложенного списка
3
\end{lstlisting}

Заметим, что нумерация элементов списка в Python начинается с нуля. 

Выполнить конкатенацию (объединение) двух списков можно с помощью перегруженного оператора \verb|+| (<<плюс>>):

\begin{lstlisting}
>>> [1, 2] + [5, 6]
[1, 2, 5, 6]
\end{lstlisting}

Кроме того, класс \verb|list| имеет набор различных методов для вставки и удаления элементов из списка: append(), insert(), remove(), pop(). А также методы для сортировки элементов списка: sort() и reverse().

Например, метод \verb|insert()| используется для вставки нового элемента в середину (или начало) списка. Первый аргумент этого метода указывает позицию, куда нужно вставить элемент, а через второй аргумент передается сам элемент:

\begin{lstlisting}
>>> L = [1, 2]
>>> L.insert(1, 3)
>>> L
[1, 3, 2]
\end{lstlisting}

Узнать длину списка можно с помощью функции \verb|len()|.

\begin{lstlisting}
>>> len([1,2,3])
3
\end{lstlisting}


Сделаем важное замечание относительно операция присваивания \verb|=|. Эта операция не производит копирование списка, а только создает еще одну ссылку на тот же список (т.е. хранящийся в той же области памяти). Это сделана для экономии ресурсов, однако может привести к неожиданным результатам при неправильном использовании. Рассмотрим пример.

\begin{lstlisting}
>>> L = [1, 2, 3]
>>> S = L
>>> L[0] = 9   # изменим первый элемент списка L
>>> L
[9, 2, 3]
>>> S				# в списке S первый элемент тоже изменился
[9, 2, 3]		# так как это один и тот же список на самом деле
\end{lstlisting}

Если же нам нужно сделать реальную копию списка, то для этих целей существует метод \verb|copy()|.

\begin{lstlisting}
>>> L = [1, 2, 3]
>>> S = L.copy()
>>> L[0] = 9
>>> L
[9, 2, 3]
>>> S       # теперь все в порядка
[1, 2, 3]   # список S не затронут
\end{lstlisting}

Это замечание справедливо и для всех остальных встроенных типов данных языка Python. В общем случае для операции присваивания действуют следующие правила:

--- Инструкция присваивания всегда создает ссылку на объект (но не создает копии объектов).

--- Переменные создаются при первом присваивании.

--- Перед использованием переменной ей должно быть присвоено значение.


\subsection{Множества}

В отличие от списков, множества не могут содержать повторяющихся элементов.

Для работы с множествами предусмотрены методы union(), intersection(), difference(), issubset(), смысл которых ясен из их названия. Посмотрим, как это выглядит на практике.

\begin{lstlisting}
>>> A = {1, 2}
>>> B = {2, 3}
>>> A.union(B)
{1, 2, 3}
>>> A.intersection(B)
{2}
\end{lstlisting}

Эти же операции можно записать в более компактной форме, используя перегруженные операторы:

\begin{lstlisting}
>>> A | B    # объединение множеств
{1, 2, 3}
>>> A & B    # пересечение множеств
{2}
\end{lstlisting}

%Заметим, что этот способ компактнее и нагляднее. Обозначения этих теоретико-множественных операций совпадают с соответствующими операциями над булевыми типами (что не должно удивлять). 

Также имеются операции нахождения разности множеств (\verb|A - B|) и симметрической разности (\verb|A ^ B|).

Кроме того, существуют операции над множествами, которые возвращают логическое значение истина или ложь. К ним относится операция сравнения двух множеств (\verb|A == B|), проверка вложенности одного множества в другое (\verb|A <= B|), принадлежность элемента множеству (\verb|x in A|) и другие.

Мощность множества \verb|A| (т.е. количество элементов в нем) можно получить с помощью функции \verb|len(A)|.


\subsection{Cтроки}

Строки в Python --- это не просто массив символов. В Python строки реализованы в виде отдельного класса. Однако операции над строками очень похожи на операции над списками. Например, конкатенация строк (оператор \verb|+|), получение символа по индексу (оператор \verb|[]|), получение длины строки (функция \verb|len()|), повторение строки (с помощью опертора \verb|*|) и другие. Следующий пример демонстрирует работу со строками.

\begin{lstlisting}[caption=Работа с строками]
>>> s = 'str'+'ing' # конкатенация
>>> s
'string'
>>> s[2]
'r'
>>> t = s*2  # удвоение строки
>>> t
'stringstring'
>>> len(t)
12
\end{lstlisting}

Получение подстроки.  Оператор извлечения среза из строки выглядит так: [X:Y]. X --- это индекс начала среза, а Y  --- его окончания; причем символ с номером Y в срез уже не входит. Если отсутствует первый индекс, то срез берется от начала до второго индекса; при отсутствии второго индекса, срез берется от первого индекса до конца строки.

\begin{lstlisting}
>>> s = "0123456789";
>>> s[0:2];
'01'
>>> s[:2];
'01'
>>> s[2:];
'23456789'
\end{lstlisting}



\subsection{Операторы сравнения}

%Операторы сравнения обычно используются для сравнения числовых выражений, но в Python они могут применяться и к другим типам данных, например, к множествам, о чем уже было сказано выше. 

Операторы сравнения производят сравнение двух элементов одного класса и в качестве результата возвращают константы True или False. Основные операторы сравнения: равно (\verb|==|), не равно (\verb|!=|), меньше (\verb|<|), больше (\verb|>|), не меньше (\verb|>=|), не больше (\verb|>=|). Например, для числовых типов:

\begin{lstlisting}
>>> 5 <= 3
False
\end{lstlisting}

Кроме того, операторы сравнения перегружены для некоторых других (не числовых) классов. Например, как уже было отмечено выше, применительно к множествам операторы \verb|<| и \verb|>| означают проверку на включение:

\begin{lstlisting}
>>> {1,2,3} > {1,3}
True
\end{lstlisting}

\subsection{Логические операции}

Для переменных логического типа \verb|bool| определены следующие операторы:  \verb|and|, \verb|or| и \verb|and|. Пример использования этих операторов:

\begin{lstlisting}
>>> (not 1==2) or False
True
\end{lstlisting}


\subsection{Преобразование типов данных}

Язык Python допускает неявное преобразование типов. Например, если сложить целое (int) и вещественное (float) числа, то результатом будет число типа \verb|float|:

\begin{lstlisting}
>>> type(3 + 4.5)
<class 'float'>
\end{lstlisting}

Явное преобразование из одного типа в другой имеет следующую форму: \verb|тип(значение)|. Рассмотрим пример преобразования строки в число типа float:

\begin{lstlisting}
>>> float('12'+'3')
123.0

\end{lstlisting}

Еще один полезный пример --- преобразования строки в список символов:

\begin{lstlisting}[caption=Преобразование строки в список символов]
>>> ls = list('string')
>>> ls
['s', 't', 'r', 'i', 'n', 'g']
\end{lstlisting}

% это можно опустить:

Правда, в обратную сторону этот способ (через \verb|str()|) не сработает. Точнее, результат будет не совсем тот, что можно ожидать:

\begin{lstlisting}
>>> str(ls)
"['s', 't', 'r', 'i', 'n', 'g']"
\end{lstlisting}

Для получения исходной строки нужно использовать специальный метод \verb|join()|:

\begin{lstlisting}
>>> ''.join(ls)
'string'
\end{lstlisting}



\subsection{Блоки, циклы и ветвления}

Оператор ветвления представлен единственной условной инструкцией \verb|if|. 

\begin{lstlisting}
if 1 > 2:
	print('условие выполнено')
\end{lstlisting}


В Python отсутствует оператор множественного выбора (switch -- case) как в C++ или JAVA. Для этих целей используется полная конструкция \verb|if|/\verb|elif|/\verb|else|, общая форма которой имеет следующий вид:

\begin{lstlisting}
if <условие1>:
	<блок1>
elif <условие2>:
	<блок2>	
else <условие3>:
	<блок3>	
\end{lstlisting}



Для реализации циклов в Python присутствуют стандартные инструкции \verb|for| и \verb|while|. Инструкция \verb|for| всегда используется в связке с ключевым словом \verb|in| и предназначена для обхода всех элементов списка, множества и любых других последовательностей. Например,

\begin{lstlisting}
for x in {3, 2, 1}:
	print(x)
\end{lstlisting}

Стандартная форма цикла \verb|while| следующая:

\begin{lstlisting}
while <условие>:
	<блок>
\end{lstlisting}

Совместно с инструкциями циклов могут использоваться стандартные инструкции \verb|break| и \verb|continue|, а также менее стандартные инструкции --- \verb|pass| и \verb|else|. Инструкция \verb|pass| --- это пустая инструкция, которая ничего не делает. Инструкция \verb|else| располагается после цикла и всегда выполняется в том случае, если цикл завершается обычном способом (без прерывния с помощью \verb|break|).

Сделаем сразу замечание относительно выделения блоков кода. В отличие от многих других языков программирования, в  Python отсутствуют какие-либо ключевые слова или конструкции для выделения блока (как, например, begin...end в языке Паскале или фигурные скобки в C++). Вместо этого используются горизонтальные отступы для того, чтобы дать понять интерпретатору, где заканчивается данный блок. Например,

\begin{lstlisting}
for x in [1, 2]:
	print(x)
	print(x^2)
print(x^3)
\end{lstlisting}

В этом примере 2-ая и 3-я строки кода включены в тело цикла for и поэтому будут выполнены дважды (для x=1 и x=2), а инструкция 4-ой строки расположена после окончания цикла, и значит выполнится только один раз (для x=2).

Для формирования последовательностей чисел с заданным шагом существует функция \\
\verb|range(start, stop, step)|. Если \verb|step>0|, то она возвращает возврастающую последовательность чисел с условием 

\verb|start <= start + i * step < stop|, 

где i --- целое неотрицательное число. Например, 

\begin{lstlisting}
>>> list(range(0, 10, 2))
[0, 2, 4, 6, 8]
\end{lstlisting}


Функция range часто используется в циклах. Например, следующий код напечатает в консоль последовательность чисел 0, 2, 4, 6, 8.

\begin{lstlisting}
for x in range(0, 10, 2):
	print(x)
\end{lstlisting}

Кроме того, \verb|range| вместе с \verb|for| часто используются для генерации списков (или других последовательностей), что демонстрирует следующий пример:

\begin{lstlisting}
>>> [x**2 for x in range(0, 10, 2)]
[0, 4, 16, 36, 64]
\end{lstlisting}



\subsection{Функции}

Как и в большинстве языков программирования, в Python можно определять собственные функции. Для создания функции предназначена5 инструкция \verb|def|. Ниже показан пример определения функции:

\begin{lstlisting}[caption=Пример объявления функции]
def sum(x,y):
	return x+y
\end{lstlisting}

По умолчанию все переменные внутри функции локальные, т.е. находится в локальной области видимости. Это вполне естественный подход. Однако есть возможность обратиться и к глобальным переменным, объявленным вне функции. Для этого имеются ключевые слова \verb|global| и \verb|nonlocal|.

Еще одни способ задания функций --- использование лямбда-нотации:

\begin{lstlisting}
>>> sum = lambda x,y: x+y
>>> sum(2,3)
5
\end{lstlisting}

Или даже так, без присвоения имени функции:

\begin{lstlisting}
>>> (lambda x,y: x+y)(2,3)
5
\end{lstlisting}

Такие анонимные (или лямбда-функции) составляют основу функционального программирования.


\subsubsection{Передача параметров по ссылке/по значению} Все параметры передаются по ссылке. Однако если переменная связана с неизменяемым значением, например int, str, tulpe, то естественно, это значение не изменится. А вот если переменная связана со списком, словарем или классом, то значение связанного с переменной объекта изменится.



\subsection{Ввод-вывод}

Для считывания строки с консоли используется функция \verb|input|, а для вывода на консоль --- функция \verb|print|.

\begin{lstlisting}
>>> str = input() # ввод строки с консоли
5
>>> x = int(str)  # преобразование в числовую форму
>>> y = x**2
>>> print(y)      # вывод на консоль
25
\end{lstlisting}


\subsection{Файлы и каталоги}

Чтение/запись данных из файла можно проводить с помощью методов \verb|read()| и \verb|write()| соответственно. Перед началом работы с файлом его необходимо открыть с помощью функции \verb|open()|, а после окончания работы --- закрыть посредством \verb|close()|. Типичный пример работы с файлом (в текстовом режиме):

\begin{lstlisting}
>>> f = open('newfile.txt','w') # открытие в режиме записи
>>> f.write('Hello')
5
>>> f.close()
>>> f = open('newfile.txt','r') # открытие в режиме чтения
>>> f.read()
'Hello'
>>> f.close()
\end{lstlisting}



















\newpage

\section{Расширения языка Python. Модули и пакеты}


Начнем однако рассмотрение этого вопроса с библиотеки NumPy, которая обычно используется для работы с матрицами. В частности, она понадобится для задания матриц смежности графов.



\subsection{Модули}

До сих пор рассматривались только функции и классы, входящие непосредственно в ядро языка Python. Их использование не требует подключения каких-либо внешних библиотек. Однако для получения большей функциональности возникает необходимость подключения (импортирования) внешних модулей. Для этого служит ключевое слово \verb|import|. 

Например, модуль \verb|math| содержит набор математических функций (\verb|sqrt|, \verb|abs|, \verb|exp|,  \verb|log|, тригонометрические функции и др.). Чтобы использовать эти функции в своей программе, необходимо импортировать модуль \verb|math|:

\begin{lstlisting}[caption=Использование модуля math]
>>> import math
>>> math.pi		# число пи
3.141592653589793
>>> math.cos(math.pi)  # вычисляем косинус числа пи
-1.0
\end{lstlisting}

При импорте модуля можно задать для него псевдоним (исключительно для удобства) с помощью ключевого слова \verb|as|, что позволит затем использовать псевдоним при обращении к атрибутам модуля. Например,

\begin{lstlisting}[caption=Использование модуля math]
>>> import math as m
>>> m.cos(m.pi)
-1.0
\end{lstlisting}

Часто полезно импортировать не весь модуль, а лишь отдельные его атрибуты (имена функций, классов и т.п.). Для этого служит инструкция \verb|from|. Кроме того, после такого импорта для вызова функции достаточно указать только ее имя (без имени модуля):

\begin{lstlisting}
>>> from math import cos, pi
>>> pi
3.141592653589793
>>> cos(pi)
-1.0
\end{lstlisting}

Существуют специальная форма инструкции from, которая позволяет импортировать сразу все атрибуты модуля:

\begin{lstlisting}
>>> from math import *
\end{lstlisting}

Однако такой подход не всегда оправдан, так как часто приводит к <<замусориванию>> пространства имен.

%Инструкции импорта не обязательно должны находится в начала всей программы, они могут идти непосредственно перед первым использованием требуемых функций.

Фактически модули в Python представляют собой просто файлы с исходным кодом либо байт-кодом (причем не обязательно написанных на языке Python). Несколько модулей могут быть помещены в отдельный каталог. Такой каталог называет пакетом. При этом полный путь к функции будет выглядеть примерно так: \verb|пакет.модуль.функция|.

Замечание. Для сравнения, в C++ для доступа к методу класса используется оператор точка, а для доступа к функциям библиотек --- оператор двойного двоеточия (\verb|::|). В Python нет существенной  разницы между модулями и классами, и поэтому в обоих случаях используется оператор точка.






\newpage

\section{ООП на Python}


\begin{lstlisting}[caption=Классы и наследование]

class A1:
	def __init__(self, x):
		self.x = x
		print('A1:init')
	
	def foo(self):
		print('A1:foo')
		print(self.x)
		
class A2:
	def __init__(self, x):
		self.x = x
		print('A2:init')
	
	def foo(self):
		print('A2:foo')
		print(self.x)		
		
class B(A1, A2):
	foo = A2.foo	# explicit inheritance
	def __init__(self, x):
		self.x = x
		#A1.__init__(self, 2)
		#A2.__init__(self, 3)
		print('B:init')

ob = B(1)
ob.foo()
\end{lstlisting}

Вывод
\begin{verbatim}
B:init
A2:foo
1
\end{verbatim}

Здесь дочерний класс \verb|B| наследует два базовых класса \verb|A1| и \verb|A2|. 

Если из класса \verb|B| убрать конструктор \verb|__init__|, то по умолчанию будет вызван конструктор одного из базовых класса, а именно первого в списке наследования, т.е. \verb|A1|. Это происходит потому, что если нет никакого конструктора, то генерируется конструктор по умолчанию?

Аналогично, когда мы вызываем функцию \verb|ob.foo()|, то возникает вопрос, какого именного базового класса будет вызывана функция. (По умолчанию) это зависит от порядка следования базовых классов в списке наследования. Однако с помощью строки \verb|foo = A2.foo| можно указать явно, функция какого класса нас интересует.





\begin{thebibliography}{10}

\bibitem{Lutc} Лутц, М. Изучаем Python / М. Лутц. --- 4-ое изд. --- Пер. с англ. --- СПб.: Символ-Плюс, 2011. --- 1280 с.




\end{thebibliography}

\end{document} 

